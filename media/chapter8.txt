# 8. Формы для работы со студентом и группою: Django формы, валидация

Вот и пришли мы с вами к главе, в которой разберемся с формами.

** Веб-формы ** - это инструмент, с помощью которого пользователь может отправить данные на сервер, а не только использовать свой браузер в режиме получения данных. Формы - это очень показательный элемент веб-разработки, который свидетельствует об уровне программиста. С одной стороны это довольно рутинная и трудоемкий работа, а с другой стороны, создать по-настоящему удобные и простые в использовании формы, далеко непростая задача.

Поэтому данная глава содержит довольно важный и сложный материал. А именно:

* верстка HTML формы;
* обработка формы на сервере, валидация данных;
* использование встроенных классов Django форм, форм моделей;
* формы с Twitter Bootstrap и приложение Django Crispy Forms;
* кастомизация Django админки.

В процессе данной главы мы с вами:

* реализуем форму добавления студента практически с нуля;
* построим форму редактирования студента используя Django формы моделей;
* реализуем функцию удаления существующих студентов;
* создадим форму контакта администратора на закладке Контакт;
* улучшим список студентов в административной части и допишем валидаторы для поля "Группа" на форме редактирования студента.

В конце у вас будет полный арсенал работы с веб-формами как на клиентской стороне, так и на стороне сервера.

А начнем мы с небольшой теоретической части, а именно - HTML формы.

## HTML Формы

Мы уже с вами совсем кратко рассмотрели теги форм и полей в главе со статической версткой веб-страницы. Здесь же немного подробнее взглянем на необходимый минимум для эффективного построения правильных форм на сайте.

### Обзор

Для пользователя форма должна быть легкая, удобная и быстрая в использовании. Любое действие пользователя, в идеале, должно иметь мгновенный фидбэк со стороны нашего кода. Если данные введены корректно, тогда после отправки данных на сервер, пользователь должен видеть сообщение, что его запрос успешно обработан, а поля формы обнулены (опять пустые). Если же данные были введены некорректно, тогда форма сохраняет ранее установленные пользователем данные в полях, а также отражает дополнительные сообщение конкретизируя ошибки пользователя для дальнейшего исправления.

Также, если форма была отправлена и обработана корректно, стоит перенаправить пользователя на другую страницу, где сообщать ему об успешность операции.

В серверной части очень важно не просто получать и сохранять данные от пользователя, а каждый раз проверять ввод данных на корректность. Иначе можем оказаться с некоректимы данными в базе, или, что еще хуже, сломанной базой данных и "взломаными" веб-страницами.

Поля формы и вид самой формы стоит оформлять в удобном для пользователя виде, добавляя необходимое количество объяснений, чтобы уберечь его от неправильно введенных данных.

Для повышения эффективности работы с формой, в наше время, большую часть полей динамизируют и улучшают с помощью богатого Javascript функционала. Например, чтобы ввести данные о дате и времени, используется виджет календаря. Для выбора цвета, используются так называемые "Color Picker".

### HTML код формы

Главный тег при работе с формами есть, конечно же, "form". Это невидимый на странице тег, указывающий на свойства формы, а также содержит поля и кнопки этой формы.

Важнейшими атрибутами тега формы есть:

* action: указывает адрес, на который отправляются данные формы;
* [enctype](http://htmlbook.ru/html/form/enctype): тип кодирования данных формы перед отправкой на сервер (может быть одним из трех: "text/plain", "multipart/form-data" и " application/x-www-form-urlencoded "; просто запомните, что нужно использовать значение" multipart/form-data ", если в форме есть поля файлов)
* method: метод запроса формы (может быть GET или POST) больше об этом атрибут в следующих секциях;
* name: название формы; форм на странице может быть много и в таком случае каждой из них стоит давать другое имя; с помощью имени можно на сервере определять, какая именно форма была отправлена ​​(особенно, если формы имеют одинаковый "action" атрибут)
* [target](http://htmlbook.ru/html/form/target): указывает, где именно отображать результат отправки формы.

Вот пример пустой формы с определенными необходимыми атрибутами:

{title="Тег form",lang="html"}
~~~~~~~~
<form action="/submit_form.html" method="post"
      enctype="multipart/form-data" name="myform">
</form>
~~~~~~~~

Пока данная форма без полей и кнопок. Внутрь тега form можем добавлять один или более следующих тегов(полей формы):

* [input](http://htmlbook.ru/html/input): самый распространенный тег внутри форм; может иметь несколько различных типов в зависимости от атрибута ["type"] (http://htmlbook.ru/html/input/type) (checkbox, radio, text, hidden, submit и еще многие другие);
* [textarea](http://htmlbook.ru/html/textarea): позволяет вводить пользователю не только строку текста, а целые параграфы текста;
* [select](http://htmlbook.ru/html/select): набор опций для выбора в виде раскрывающегося списка (выпадающее меню); работает в двух режимах, позволяя выбирать как только одно значение, так и несколько значений одновременно (атрибут "multiple") опции для выбора формируются за счет вложенных тегов ["option"] (http://htmlbook.ru/html/option)
* [button](http://htmlbook.ru/html/button) или input[type = submit]: кнопки на форме; в основном используются для отправки формы на сервер;
* [label](http://htmlbook.ru/html/label): подписывает поле пояснительным текстом; с помощью атрибута "for" можно фокусировать поле при клике по тегу "label".

Зная и понимая, как именно использовать вышеперечисленные теги и их атрибуты, вы без проблем сможете реализовать 90% необходимых в вашем проекте форм.


A> button vs input[type=submit]: есть два теги, с помощью которых можно реализовать кнопки формы. Оба есть равноценными по функционалу. Но button дает лучшие визуальные возможности. В частности, в тег button можно вкладывать внутренний контент. Поэтому, в принципе, не так важно каким именно тегом вы будете пользоваться.

А теперь, давайте сверстаем простую форму, где воспользуемся несколькими из вышеупомянутых тегов:

{title="Демо HTML форма",lang="html"}
~~~~~~~~
<form action="/submit_form.html" method="post"
      enctype="multipart/form-data" name="myform">

  <input type="hidden" value="27" name="student_id" />

  <div>
    <label for="first_name">Ваше имя</label>
    <input type="text" value="" name="first_name"
           id="first_name" />
  </div>

  <div>
    <label for="graduated">Закончили обучение?</label>
    <input type="checkbox" checked="1" name="graduated"
           value="1" id="graduated" />
  </div>

  <div>
    <label for="gender">Ваш пол</label>
    <input type="radio" name="gender" value="male"
           id="gender" />
    <input type="radio" name="gender" value="female" />
  </div>

  <div>
    <label for="age">Ваш возраст</label>
    <select name="age" id="age">
      <option value="">
        Пожалуйста, выберите ваш возраст
      </option>
      <option value="10">Больше 10</option>
      <option value="20">Больше 20</option>
    </select>
  </div>

  <input type="submit" name="save_button"
         value="Сохранить" />

</form>
~~~~~~~~

A> Если вместо кириллицы в браузере получили "абру-кадабру", тогда добавьте в шапку документа (тег head) тег с кодировкой UTF-8: '\<meta charset="UTF-8"/\>'. После этого нужно перезагрузить страницу.

Как видите, тег формы может содержать и другие теги. Мы обернули каждое поле в тег "div", чтобы логически сгруппировать поле ввода и соответствующую метку (тег "label"). Кроме того, данный тег отделил каждое поле в отдельную строку.

Обратите особое внимание на то, как работают поля "checkbox", "radio" и "select".

Вот как будет выглядеть данная форма в браузере:

![Демо форма](images/html_form_demo.jpg)

A> На домашнее задание: расширьте данную форму большим количеством полей так, чтобы все вышеперечисленные теги формы были задействованы.

Этого нам будет достаточно, чтобы дальше двигаться к практике. Но перед практикой рассмотрим еще несколько интересных моментов.

### GET vs POST

Веб-формы могут делать запросы на сервер двух типов: GET i POST.

Как мы уже помним из предыдущих глав, когда мы  открываем страницы с помощью URL адреса браузера, а также кликаем по ссылкам, мы автоматически делаем запросы на сервер типа GET. Этот тип запроса получает данные с сервера.

Для отправки данных на сервер в форме чаще используется метод POST. Он позволяет отправить большее количество данных, в то время как метод GET имеет очень ограниченный объем данных для отправки на сервер.

Если вам нужно сделать форму, которая изменяет данные на сервере, тогда используйте метод запроса POST. Если же только получить данные с сервера и при этом объем данных отправляется небольшой, тогда метод GET.

Также метод POST лучший тогда, когда форма содержит поля, которые не следует отражать в URL адресе браузера. Например пароль. С другой стороны, если адрес запроса со всеми полями нужен для дальнейшего запоминания пользователю (например, в закладке), тогда стоит воспользоваться методом GET. Это бывает полезно для форм поиска и фильтров данных, чтобы позже пользователь мог легко попасть на предварительно настроенную страницу с результатами поиска.

Таким образом POST будет подходящим для форм добавления, редактирования и удаления студента. В то время, как GET лучше подойдет для формы поиска на сайте.

### Валидация

Если слишком доверять всем данным, которые приходят к нам от пользователя, то можем закончить полностью с поломанной базой данных и веб-сайтом.

Чтобы избежать подобных ситуаций, как правило, данные форм проверяются на корректность. В идеале эту проверку делают в двух местах: на стороне браузера и на стороне сервера.

Если проверка на странице необязательна, и скорее служит для удобства пользователя и скорости работы с формой, то серверная валидация данных - это просто необходимость.

Наиболее распространенными примерами валидации форм являются:

* проверка на ввод данных в обязательные поля формы;
* проверка на правильный формат телефонов, емейл, дат;
* проверка на достаточно сложный и правильный ввод пароля;
* правильный тип файла и ограничения на размер файла.

Наша задача, как разработчиков, на сервере, перед выполнением любых операций над данными с формы, проверить их корректность. И только, если все данные пользователя удовлетворяют необходимым условиям, продолжать обработку данных.

Если данные введены неправильно, дальнейшая работа с ними прекращается и форма отправляется пользователю повторно. Поля формы сохраняют ранее установленные пользователем данные. Также обновленная форма должна вывести детали ошибок.

### Безопасность

В завершение теоретического вступления в HTML формы рассмотрим вопрос безопасности при работе с формами.

Необходимый минимум вещей, которые нам нужно применять к нашим формам, чтобы избежать большинства атак злоумышленников, это:

* шифрование данных форм при отправке на сервер с помощью SSL сертификатов и протокола [HTTPS] (http://uk.wikipedia.org/wiki/HTTPS)
* защита от подделки запроса от имени пользователя; так называемый [CSRF] (http://bit.ly/vpcsrq) (Cross Site Request Forgery атака).

**HTTPS**

Большинство форм авторизации и регистрации (и все формы, передающие с веб-страницы на сервер пароли пользователя) в интернете работают не по протоколу HTTP, а через HTTPS.

![HTTPS протокол для форм с паролем](images/https_login.jpg)

К страницам, обслуживаемых через протокол HTTPS применяют SSL сертификат, с помощью которого запрос на сервер и ответ от него шифруются. Поэтому, даже если кто-то перехватит данные, они будут зашифрованы. Кроме того HTTPS протокол проверяет действительно ли мы общаемся с настоящим сервером, а не подставным.

*Таким образом, следует придерживаться простого правила: если вы имеете дело с формой, которая отправляет важные секретные данные, страница, на которой данная форма находится, должна обслуживаться через HTTPS протокол.*

**CSRF**

Вторым базовым способом защиты форм является защита против подделки запроса. Представьте, что обработчик вашей формы запустили не со страницы формы, а с кода, или ссылки на форуме. А кликнул данную ссылку ваш пользователь, не зная о том, что данная ссылка перейдет на обработчик данной формы. В браузере в то время могут оставаться данные сессии пользователя (например данные cookies) и запрос пройдет успешно от имени данного авторизованого на вашем сайте пользователя. Это может привести к неожиданным и необратимым изменениям на вашем сайте.

Больше о CSRF можете почитать [здесь](http://bit.ly/vpcsrq).

Данная проблема решается довольно просто. У себя на форму вставляете скрытое поле с определенным автоматически сгенерированным кодом, а в обработчике формы проверяете, получили обратно правильный код с данной формы или нет. Django уже дает нам возможность генерации такого кода, а также саму валидацию для каждой нашей формы.

Мы вернемся к CSRF проблеме, когда будем разрабатывать нашу первую форму - форму добавления студента.

C> ...

На этом заканчиваем с теорией и переходим к практике:

## Форма добавления студента

Начнем с реализации формы добавления студента.

Данную форму разработаем наиболее длинным путем: написав HTML код формы самостоятельно с нуля, а также логику на сервере (включая валидацию) собственными силами.

В следующей секции мы создадим форму редактирования студента. И там мы воспользуемся Django формами, которые для нас сделают всю тяжелую часть и по генерации HTML кода, и по валидации, и по сохранении изменений в базу данных.

Однако, перед тем, как использовать базуку, нам сначала нужно разобраться как стрелять из пистолета. Поэтому, перед использованием всего готовенького, сначала учимся самостоятельно писать форму и ее обработчик. Это поможет нам дальше понять, что же заложено в классы Django форм.


### Подключаем шаблон

В предыдущих главах мы уже подключили вьюшку и URL шаблон для формы редактирования студента. Но мы сделали так, чтобы эта вьюшка возвращала статический текст. Поэтому давайте переключим ее на использование шаблона.

Для этого сначала создадим шаблон, скопировав его с students_list.html:

{title="Подготовка шаблона students_add.html",lang="shell"}
~~~~~~~~
# переходим в приложение, папку с шаблонами
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/templates/students

# копируем students_list.html шаблон
$ cp students_list.html students_add.html
~~~~~~~~

Теперь подключим новый шаблон к вьюшке с добавлением студента:

{title="Подключаем шаблон, модуль views.py",lang="python"}
~~~~~~~~
def students_add(request):
    return render(request, 'students/students_add.html',
        {})
~~~~~~~~

Думаю, код выше не требует объяснений. Подобную вещь мы уже делали в функции вьюшки списка студентов.

### HTML Форма

Пришло время заняться самим шаблоном и создать форму добавления студента.

Открываем шаблон students_add.html в редакторе, обновляем заголовки и удаляем все содержимое блока "content".

{title="Начальные приготовления страницы редактирования студента",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}

{% block meta_title %}Добавить Студента{% endblock meta_title %}

{% block title %}Добавить Студента{% endblock title %}

{% block content %}

Скоро здесь будет форма добавления студента

{% endblock content %}
~~~~~~~~

Примерно вот так будет выглядеть наша заготовка в браузере, когда щелкнем на кнопку Добавить Студента:

![Заготовка страницы Добавить Студента](images/student_add_boilerplate.jpg)

Пришли к главному - к самой форме. Добавляем тег "form", а внутри для каждого поля модели студента добавляем соответствующее поле ввода для пользователя:

{title="Базовая форма добавления студента",lang="html"}
~~~~~~~~
<form action="{% url "students_add" %}" method="post"
      enctype="multipart/form-data">

  <div>
    <label for="first_name">Имя</label>
    <input type="text" value=""
           name="first_name" id="first_name" />
  </div>
  <div>
    <label for="last_name">Фамилия</label>
    <input type="text" value=""
           name="last_name" id="last_name"
           placeholder="Введите ваше имя" />
  </div>
  <div>
    <label for="middle_name">Отчество</label>
    <input type="text" value=""
           name="middle_name" id="middle_name" />
  </div>
  <div>
    <label for="birthday">Дата Рождения</label>
    <input type="text" value=""
           name="birthday" id="birthday"
           placeholder="Напр. 1984-12-30" />
  </div>
  <div>
    <label for="photo">Фото</label>
    <input type="file" value="" name="photo" id="photo" />
  </div>
  <div>
    <label for="ticket">Билет</label>
    <input type="text" value=""
           name="ticket" id="ticket" />
  </div>
  <div>
    <label for="student_group">Группа</label>
    <select name="student_group" id="student_group">
      <option value="">Виберите группу</option>
      <option value="1">МтМ-1</option>
      <option value="2">МтМ-2</option>
    </select>
  </div>
  <div>
    <label for="notes">Дополнительные Заметки</label>
    <textarea name="notes" id="notes" class="form-control"></textarea>
  </div>
  <div>
    <input type="submit" value="Добавить" name="add_button" />
    <button type="submit" name="cancel_button">Отменить</button>
  </div>
</form>
~~~~~~~~

Пройдемся по всем важным моментам данной формы:

* 1я строка: form - тэг формы; его атрибут action указывает на эту же страницу, на которой находится наша форма добавления студента; то есть генератор формы и обработчик формы у нас будет тот же - функция вьюшки добавления студента; в зависимости от типа запроса (GET или POST) наша вьюшка выполняет две разные вещи; метод запроса нужно использовать POST, ведь мы хотим менять данные на сервере с помощью данной формы; тип кодирования данных перед отправкой на сервер: "multipart/form-data", ведь нам нужно будет отправлять файл фото студента;
* 4я: div - каждое поле состоит, как минимум, из двух тегов: метки поля (label) и самого поля ввода; каждую такую ​​пару мы оборачиваем в блочный элемент div, чтобы визуально отделить поля и поставить их в отдельные строки;
* 5я: label - для каждого поля ввода добавляем этот тег; он добавляет объяснение о назначении поля, а также с помощью атрибута "for", привязывает фокус поля при клике по метке; "for" атрибут содержит "id" поля, которому соответствует тег "label";
* 6я: input - поле текстровой строкм для поля Имя студента; значение поля (value) пустое;
* 13я: placeholder - этот атрибут вставляет в поле текст, который мы обычно используем для объяснения пользователю, что нужно ввести в данное поле; как только пользователь начинает вводить текст в это поле, placeholder строка сразу исчезает; на домашнее задание: добавьте атрибут "placeholder" ко всем полей формы;
* 28я: input [type=file] - поле типа "file" предназначено для отправки файлов на сервер;
* 37я: select - данный тег используем для отображения списка существующих групп в приложении;
* 38я: option - с помощью данного тега набиваем список групп; в данный момент он у нас статический, позже мы его будем заполнять динамически существующими группами из базы;
* 45я: textarea - тег для ввода многострочного текста; вместо атрибута "value", значение данного поля вводится внутри тега;
* 49я: input - поле типа "submit" предназначено для отправки данных формы на сервер; по атрибуту "name" можем на сервере идентифицировать, какая именно кнопка была нажата при отправке данных; атрибут "value" используется для текста на кнопке; также отправить данные на сервер можно нажав кнопку "Enter" имея сфокусированным одно из полей формы; при этом будет автоматически запущена первая кнопка на форме;
* 50я: button - аналогично поля input с типом "submit", можно использовать тег button; он аналогичен по функционалу, но лучший в случае, если нужно добавить кастомные стили к кнопке.

Сохраняем обновленный шаблон и обновляем страницу в браузере:

![Базовая форма добавления студента](images/base_student_add_form.jpg)

Уже достаточно неплохо! Поэтому переходим к вьюшке и поработаем с Python кодом.

### Обновляем вьюшку

Первым делом обновим поле "Группа" списком реальных групп из базы данных. Для этого передадим с вьюшки в шаблон список групп:

{title="Передаем группы в шаблон, students.py модуль в пакете views.",lang="python"}
~~~~~~~~
from ..models import Student, Group

def students_add(request):
    return render(request, 'students/students_add.html',
        {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

Буквально одной строкой мы получили список групп в базе данных рассортированных по имени и передали их под ключом 'groups'. Таким образом можем теперь им воспользоваться в шаблоне:

{title="Список существующих групп готов",lang="html"}
~~~~~~~~
<select name="student_group" id="student_group">
  <option value="">Виберите группу</option>
  {% for group in groups %}
  <option value="{{ group.id }}">{{ group.title }}</option>
  {% endfor %}
</select>
~~~~~~~~

В 3й строке мы проходим в цикле по списку "groups". В теле данного цикла мы создаем теги "option", значениями которых есть уникальные идентификаторы групп (id), имя группы используем для визуального представления пользователю.

Попробуйте теперь перегрузить вашу страницу и убедитесь, что выпадающий список с группами отражает существующие группы из базы данных.

В данный момент наша вьюшка умеет только показывать форму добавления студента, но еще не умеет обрабатывать пост данной формы. Наша задача состоит в том, чтобы научить эту вьюшку:

* проверять состоялась ли отправка формы;
* если произошла, тогда проверить входные данные;
* если данные верны, создать и сохранить нового студента в базу;
* вернуться на список со студентами;
* если данные неправильные, вернуть форму и указать пользователю на указанные ошибки;
* при этом желательно оставить предыдущие значения полей введеные пользователем
* если форма отправленна, но была нажата кнопка "Отменить", тогда просто переводим пользователя на страницу со списком студентов;
* если же форма не отправлялась, просто показываем начальную пустую форму.

Давайте начнем постепенно обновлять нашу вьюшку. Лучшим вариантом будет начать с псевдокода - добавить комментарии по общей логике (так как мы это описывали в списке выше) с кодом вьюшки:

{title="Реализуем вьюшку на псевдокоде",lang="python"}
~~~~~~~~
def students_add(request):
    # Если форма была отправлена:

        # Если кнопка Отменить была нажата:

            # Возвращаем к списку студентов

        # Если кнопка Добавить была нажата:

            # Проверяем данные на корректность и собираем ошибки

            # Если данные былы введены некорректно:
                # Отдаем шаблон формы вместе с найденными ошибками

            # Если данные былы введены корректно:
                # Создаем и сохраняем студента в базу

                # Возвращаем к списку студентов

    # Если форма не была отправлена:
        # возвращаем код начального состояния формы
        return render(request, 'students/students_add.html',
            {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

Для чего мы это делаем? Для того, чтобы получить полную картину необходимой логики, и уже потом, имея общий поток действий во вьюшке, по-немного заполнять реальным кодом. Таким образом, мы будем постепенно расширять нашу функцию более сложным кодом.

A> Рекомендую использовать данный подход "псевдокода" в собственной ежедневной практике. Он поможет вам с самого начала лучше моделировать ваш код, API и архитектуру ваших проектов.

Начнем с самых простых вещей: проверка отправки формы, а также сохранения студента. А валидацию данных оставим наконец, поскольку это будет самая сложная часть логики нашей вьюшки.

Вот как будет выглядеть код функции с обновленными условиями:

{title="Добавляем проверку на отправку формы и создаем студента",lang="python"}
~~~~~~~~
from django.shortcuts import render
from django.http import HttpResponse, HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger

from ..models import Student, Group

def students_add(request):
    # was form posted?
    if request.method == "POST":
        # was form add button clicked?
        if request.POST.get('add_button') is not None:

            # TODO: validate input from user
            errors = {}

            if not errors:
              # create student object
              student = Student(
                  first_name=request.POST['first_name'],
                  last_name=request.POST['last_name'],
                  middle_name=request.POST['middle_name'],
                  birthday=request.POST['birthday'],
                  ticket=request.POST['ticket'],
                  student_group=
                      Group.objects.get(pk=request.POST['student_group']),
                  photo=request.FILES['photo'],
              )

              # save it to database
              student.save()

              # redirect user to students list
              return HttpResponseRedirect(reverse('home'))

            else:
                # render form with errors and previous user input
                return render(request, 'students/students_add.html',
                    {'groups': Group.objects.all().order_by('title'),
                     'errors': errors})
        elif request.POST.get('cancel_button') is not None:
            # redirect to home page on cancel button
            return HttpResponseRedirect(reverse('home'))
    else:
        # initial form render
        return render(request, 'students/students_add.html',
            {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

Мы заменили практически весь псевдокод кроме валидации данных. Так что же именно мы сделали:

* 2я строка: импортируем HttpResponseRedirect класс, который используем для редиректа браузера на страницу со списком студентов при успешной обработке формы;
* 11я: POST - проверяем была ли отправлена форма; в таком случае метод запроса будет "POST";
* 13я: проверяем была ли нажата кнопка Добавить Студента; если была, кнопки формы также попадают в словарь POST объекта запроса; вот почему важно корректно установить атрибут "name" для тега кнопки;
* 15я: оставляем комментарий TODO (задачи на будущее), чтобы потом не забыть добавить сюда логику по валидации данных из формы; мы определили переменную-словарь errors, в которую позже будем добавлять найденные ошибки; а пока он у нас пустой;
* 18я: проверяем нет ли ошибок валидации данных;
* 20я: если ошибок нет (то есть словарь errors пустой), создаем объект студента; ему передаем данные из словаря POST; поскольку наша форма имеет метод "POST", то и данные на сервер пришли в словаре POST; если бы форма работала через метод "GET", тогда, соответственно, мы должны были работать на сервере с атрибутом GET объекта запроса;
* 26я: как вы знаете, поле модели ForeignKey требует в качестве значения объект класса модели; именно поэтому в данной строке мы получаем из базы данных группу идентифицированную через поле "student_group"; это поле есть равным "ID" полю группы; метод "get" вернет нам единственный уникальный объект формы с данным "ID";
* 29я: файлы в форме приходят к нам по-другому, чем остальные поля; а именно в атрибуте запроса "FILES";
* 33я: сохраняем созданного студента в базу данных; на этом этапе, если передаваемые данные некорректны, или  не хватает определенных обязательных полей модели, получим ошибку; поэтому для теста данного кода, пока у нас нет валидации, введите все поля на форме правильным образом;
* 36я: после успешного сохранения студента перенаправляем пользователя на список студентов; для этого возвращаем из нашей функции объект класса HttpResponseRedirect с переданным ему параметром: адресом страницы, на которую перенаправить пользователя; данный адрес мы сформировали с помощью функции reverse, которую импортировали в начале модуля; минимальный набор аргументов данной функции - это название URL шаблона, который мы описали в модуле urls.py; функция reverse является аналогом шаблонного тега url;
* 38я: начинаем ветку кода, которая выполняется при неудачной валидация ввода от пользователя;
* 40я: в этом случае мы повторно показываем форму добавления студента, но на этот раз еще и передаем в шаблон наш словарь с ошибками "errors"; позже, когда появится валидация, также обновим шаблон, чтобы он правильно использовал данные ошибки для отображения пользователю;
* 43я: проверяем нажал ли пользователь кнопку "Отмена";
* 45я: если да, тогда просто перенаправляем пользователя на страницу со списком студентов;
* 46я: наша начальная ветка: отображаем исходное состояние формы, если тип запроса не является "POST".

A> *HTTP редирект* - это перенаправления браузера на другую страницу. Внутри данный редирект осуществляется с помощью HTTP заголовка "Location", которому передают, в качестве значения, URL адрес на другую страницу. Данный заголовок устанавливается сервером и обычно используется после успешной обработки формы.

Попробуйте теперь перезагрузить вашу страницу с формой добавления студента, заполнить все поля корректными данными (поле даты заполните в формате [год]-[месяц]-[день], например. "1992-10-30") и нажмите кнопку Добавить. Вы должны перейти на страницу списка студентов и там, в самом конце списка, найти вашего только что созданного студента. Зайдите в админ часть Django сайта и убедитесь, что все введенные вами поля присутствуют в объекте студента.

A> Получили ошибку "CSRF verification failed. Request aborted."? Так и было задумано;-) Как мы уже с вами разобрались в первой секции данной главы, Django фреймворк обязательно проверяет каждую форму на наличие определенного кода, чтобы избежать CSRF атаки. Чтобы доработать нашу форму для данной валидации просто добавьте вот этот тег где-нибудь внутри тега form: "{% csrf_token %}". Он вставит нам скрытое поле с заранее сгенерированным кодом для дальнейшей верификации при отрпавке формы. Теперь все должно работать.

Также попробуйте воспользоваться кнопкой Отмена. Вы должны вернуться на список студентов, но на этот раз без каких-либо изменений в базе данных.

Если что-то не получается как описано выше, просмотрите приведеный в книге код, просмотрите ваш собственный код и попробуйте запустить. В конце концов, посмотрите в код, который идет вместе с книгой и сравните, что у вас не так.

### Валидация данных

Переходим к валидации. Валидация является одной из самых ответственных частей работы с формой, и в то же время одной из самых тяжелых. Если недосмотреть и пропустить какой то мелкий момент, то можно остаться с поломанной базой или веб-сайтом.

Для более-менее приличной валидации на нашей форме нам нужно:

* обозначить обязательные поля на форме;
* проверить поля на корректно введенные данные;
* каждое неверно введено поле, или поле, которое является обязательным для ввода, но пользователь его пропустил, должно быть упомянутым в словаре 'errors'; в данном словаре мы добавляем ключи одноименные с названиями полей, а значениями будут строки текста (сообщения) для пользователя с деталями ошибок;
* если есть хотя бы одна ошибка, тогда отдаем шаблон формы;
* при этом показываем ошибки у каждого поля с некорректными данными;
* а также, для удобства пользователя, сохранять в полях формы предварительно введенные данные; иначе пользователю придется каждый раз вводить даже те данные, которые были введены корректно прошлый раз.

Начнем с простого, обозначим все обязательные поля на форме дополнительной звездочкой, идущей сразу после текста метки:

{title="Отмечаем звездочкой поле Имя",lang="html"}
~~~~~~~~
  <div>
    <label for="first_name">Имя*</label>
    <input type="text" value=""
           name="first_name" id="first_name" />
  </div>
~~~~~~~~

Во второй строке можно видеть символ звездочки сразу после слова "Имя". Добавьте такую звездочку ко всем обязательным полям модели Student: Имя, Фамилия, Дата Рождения, Билет и Группа.

Теперь пользователь будет знать, что данные поля являются обязательными и это сохранит ему несколько секунд повторной отправки данных формы.

Следующим шагом добавим в нашу вьюшку Python код, который будет проверять все обязательные поля и возвращать ошибки, если их не хватит:

{title="Валидируем обязательные поля",lang="python",starting-line-number=15}
~~~~~~~~
            # errors collection
            errors = {}
            # validate student data will go here
            data = {'middle_name': request.POST.get('middle_name'),
                    'notes': request.POST.get('notes')}

            # validate user input
            first_name = request.POST.get('first_name', '').strip()
            if not first_name:
                errors['first_name'] = u"Имя обязательно"
            else:
                data['first_name'] = first_name

            last_name = request.POST.get('last_name', '').strip()
            if not last_name:
                errors['last_name'] = u"Фамилия обязательна"
            else:
                data['last_name'] = last_name

            birthday = request.POST.get('birthday', '').strip()
            if not birthday:
                errors['birthday'] = u"Дата Рождения обязательна"
            else:
                data['birthday'] = birthday

            ticket = request.POST.get('ticket', '').strip()
            if not ticket:
                errors['ticket'] = u"Номер билета обязательный"
            else:
                data['ticket'] = ticket

            student_group = request.POST.get('student_group', '').strip()
            if not student_group:
                errors['student_group'] = u"Выберете группу для студента"
            else:
                data['student_group'] = Group.objects.get(pk=student_group)

            photo = request.FILES.get('photo')
            if photo:
                data['photo'] = photo

            # save student
            if not errors:
                student = Student(**data)
                student.save()

                # redirect to students list
                return HttpResponseRedirect(reverse('home'))
            else:
                # render form with errors and previous user input
                return render(request, 'students/students_add.html',
                    {'groups': Group.objects.all().order_by('title'),
                     'errors': errors})
~~~~~~~~

Выше приведена только часть вьюшки добавления студента. Ту часть, где мы имели "TODO" заметку для дальнейшего кода валидации.

Давайте пройдемся подробнее по последним обновлениям:

* 16я: создаем переменную-словарь для сбора найденных ошибок;
* 18я: в словарь data будем собирать корректные и нормализованые данные из формы; мы сразу в нем прописали два поля, которые не нуждаются в дополнительной валидации: Заметки и Отчество;
* 22я: вытаскиваем имя студента с формы (атрибута POST) и обрезаем по краям ненужные пробелы; таким образом, не пропускаем от пользователя строки, содержащие только пробелы;
* 23я: проверяем не пуста ли строка;
* 24я: если пустая, тогда добавляем в словарь errors под ключом названия текущего поля строку-сообщение об ошибке;
* 26я: если поле имени введено корректно, то добавляем его в словарь data, на базе которого позже создадим объект студента;
* 28я: подобную вещь проделываем с полями Фамилия, День Рождения, Билет, Группа и полем Фото;
* 62я: как видите, теперь мы не вытаскиваем все переменные еще раз с POST, а взамен используем уже готовый словарь data; с помощью специального синтаксиса двух звезд мы можем функции передать развернутый в keyword аргументы словарь; эффект будет такой же, как и при передаче направления аргументов "first_name =" и т.д .;
* 71я: если есть ошибки, то передаем их в шаблон с формами.

Теперь давайте обновим наш шаблон так, чтобы воспользоваться переданными ошибками:

{title="Виводим ошибки в форму",lang="html"}
~~~~~~~~
  <div>
    <label for="first_name">Имя*</label>
    <input type="text" value=""
           name="first_name" id="first_name" />
    <span class="help-block">{{ errors.first_name }}</span>
  </div>
~~~~~~~~

В поле "Имя" мы добавили еще один тег. На этот раз это span с классом [help-block] (http://getbootstrap.com/css/#forms-control-validation). Внутри него можно увидеть переменную "errors.first_name". Из словаря errors мы пробуем вытащить ключ "first_name". Если его не существует, шаблон тихо проигнорирует данную проблему без каких-либо ошибок о несуществующем ключе.

Добавьте самостоятельно подобный span тег ко всем полям, при этом изменив ключ на название соответствующего поля.

После этого обновите страницу с формой в браузере. Не вводите никаких данных и нажмите кнопку Добавить. В результате данного действия вы должны остаться на форме, но теперь форма дает вам знать детали ошибок ввода:

![Базовая валидация формы работает](images/student_add_validate_base.jpg)

Хорошо. Базовая валидация есть, показывается в форме для пользователя и форму мы не пропускаем на запись данных, если есть некорректные данные. Но нам не хватает еще более расширенных проверок. В частности, для поля даты нам нужно проверять что формат строки является правильным.

Для поля группы нужно проверять существует ли она в базе. Иначе наша вьюшка просто сломаться вместо того, чтобы возвращать форму с хорошими сообщениями об ошибках.

Вот полный обновленный код функции вьюшки формы добавления студента:

{title="Код с расширенной валидацией данных",lang="python"}
~~~~~~~~
# новый импорт в модуле
from datetime import datetime

def students_add(request):
    # was form posted?
    if request.method == "POST":
        # was form add button clicked?
        if request.POST.get('add_button') is not None:
            # errors collection
            errors = {}

            # data for student object
            data = {'middle_name': request.POST.get('middle_name'),
                    'notes': request.POST.get('notes')}

            # validate user input
            first_name = request.POST.get('first_name', '').strip()
            if not first_name:
                errors['first_name'] = u"Имя обязательно"
            else:
                data['first_name'] = first_name

            last_name = request.POST.get('last_name', '').strip()
            if not last_name:
                errors['last_name'] = u"Фамилия обязательна"
            else:
                data['last_name'] = last_name

            birthday = request.POST.get('birthday', '').strip()
            if not birthday:
                errors['birthday'] = u"Дата Рождения обязательна"
            else:
                try:
                    datetime.strptime(birthday, '%Y-%m-%d')
                except Exception:
                    errors['birthday'] = \
                        u"Введите корректный формат даты (напр. 1984-12-30)"
                else:
                    data['birthday'] = birthday

            ticket = request.POST.get('ticket', '').strip()
            if not ticket:
                errors['ticket'] = u"Номер билета обязательный"
            else:
                data['ticket'] = ticket

            student_group = request.POST.get('student_group', '').strip()
            if not student_group:
                errors['student_group'] = u"Выберете группу для студента"
            else:
                groups = Group.objects.filter(pk=student_group)
                if len(groups) != 1:
                    errors['student_group'] = u"Выберете корректную группу"
                else:
                    data['student_group'] = groups[0]


            photo = request.FILES.get('photo')
            if photo:
                data['photo'] = photo

            # save student
            if not errors:
                student = Student(**data)
                student.save()

                # redirect to students list
                return HttpResponseRedirect(reverse('home'))
            else:
                # render form with errors and previous user input
                return render(request, 'students/students_add.html',
                    {'groups': Group.objects.all().order_by('title'),
                     'errors': errors})
        elif request.POST.get('cancel_button') is not None:
            # redirect to home page on cancel button
            return HttpResponseRedirect(reverse('home'))
    else:
        # initial form render
        return render(request, 'students/students_add.html',
            {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

Что же, изменилось в нашей функции:

* 34я: мы обновили ветку валидации поля Дата Рождения; Теперь не только проверяем на наличие данное поле, но и на правильный формат; для этого мы используем ранее импортированный модуль datetime (это встроенный модуль языка Python) и пользуемся функцией strptime, чтобы попытаться превратить строку в Python datetime объект; если строка не удовлетворяет указанному формату, данная функция выбросит ошибку; именно поэтому мы обернули ее вызов в "try/except" ветку; больше о работе с датами в Python можете почитать [здесь] (http://asvetlov.blogspot.com/2012/10/format.html)
* 37я: если переданая строка имеет неправильный формат, мы выдаем отдельное сообщение и напоминаем о правильном формате для поля даты;
* 55я: мы немного обновили работу с полем группы; мы получаем группу из базы данных через метод filter, что позволит нам избежать ошибок в Python коде, если по данной ID (student_group) не обнаружится группы в базе данных; групп с данной ID должно быть ровно 1; если это не так, выдаем пользователю сообщение, что группа выбрана неверно.

Остальной код в данной функции остался неизменным.

A> На домашнее задание реализуйте валидацию поля Фото. Файл фото должен быть не более 2 мегабайт и быть действительно файлом изображения. Подсказка: примитивный вариант валидации типа файла может быть по расширению имени файла. Более сложный и более надежный метод будет валидация через содержимое файла. Это можно сделать либо с помощью Python библиотеки PIL, или используя Django валидатор. Начните с простого варианта, а дальше попробуйте сложнее. Более сложный вариант потребует от вас немалого времени для реализации.

C> ...

Вам удобно каждый раз перенабирать все поля формы после каждой неудачной валидации данных? Мне тоже нет. Поэтому давайте, сделаем так, чтобы все ранее введенные данные оставались в форме, если валидация данных не прошла.

Это делается довольно просто. Генерация шаблона происходит при обработке того же запроса, что и запуск вьюшки. Соответственно, объект запроса (request) будет одинаковым как для вьюшки, так и для шаблона. Итак, имеем в шаблоне доступ ко всем данным из формы. Давайте вставим в значения полей формы те данные, которые есть в запросе:

{title="Сохраняем данные пользователя в форме после неудачной валидации",lang="html"}
~~~~~~~~
  <div>
    <label for="first_name">Имя*</label>
    <input type="text" value="{{ request.POST.first_name }}"
           name="first_name" id="first_name" />
    <span class="help-block">{{ errors.first_name }}</span>
  </div>
~~~~~~~~

Как видите все достаточно просто. Переменную "{{ request.POST.first_name }}" мы вставили значеннием в атрибут "value" тега input. Проделайте подобное обновление всех полей самостоятельно.

Думаю вас должна озадачить поле Группа?...

Тег select заслуживает отдельного внимания. Логика по выбору нужной опции в данном теге требует немного больше кода:

{title="Устанавливаем предыдущее значение в поле Группа",lang="html"}
~~~~~~~~
<select name="student_group" id="student_group"
        class="form-control">
  <option value="">Виберите группу</option>
  {% for group in groups %}
  <option value="{{ group.id }}" {% if group.id == request.POST.student_group|add:0 %}selected="1"{% endif %}>{{ group.title }}</option>
  {% endfor %}
</select>
~~~~~~~~

В тег option мы добавили тег условия. Если текущая группа итерации равняется предварительно выбранной группе, тогда маркируем текущий тег option как "selected". Обратите внимание, что мы сравниваем "id" объекта группы (данное поле числом) с ключом "student_group" (который является юникод строкой), что находится в посте запроса. Поэтому, чтобы перевести оба операнда операции сравнения в числовой тип, мы добавляем фильтр "add: 0" к переменной "student_group". Данный фильтр попытается приплюсовать к строке "student_group" ноль и результат вернет в виде числа. Этот хак мы применили специально, чтобы получить с обеих сторон знака сравнения операнды типа integer.


A> Полю input типа "file" нельзя никаким образом установить значения, кроме как пользователь сам изберет. Это ограничение сделано специально для безопасности в интернете. Иначе мы бы могли с сервера или Javascript кода самостоятельно присоединить файл в форме с машины нашего пользователя. Доступ к вашей файловой системы любым веб-сайтом в интернете, сами понимаете, был бы плохой идеей. Для обхода данного ограничения можно реализовать Ajax формы без перегрузки страницы, что позволит пользователю впоследствии не присоединять файл каждый раз при вводе некорректных данных на форме.

Таким образом мы с вами полностью разработали HTML код формы и логику ее работы. Данная логика правильно обрабатывает обе кнопки на форме, проверяет данные формы, выводит ошибки о некорректных данных, создает и сохраняет студента и выводит предварительные данные пользователя в случае ошибок.

Наша форма практически готова. Осталось сделать две вещи:

* добавить глобальные статусные сообщения о результатах действий пользователя с формой;
* заставить форму выглядеть немного лучше со стилями от Twitter Bootstrap..

### Статусные сообщения

На данный момент, когда вы добавляете студента или отменяете изменения, вы переходите на страницу со списком студентов. Однако в обоих случаях не совсем понятно, что на самом деле произошло. Было бы хорошо на этой странице показать сообщение пользователю о результате выполненных действий.

Именно это мы и сделаем в этой секции. Реализуем статусные сообщения, которые, на данный момент, будут работать согласно следующим трем сценариям:

* если форма была отправлена ​​на сервер, но возникли ошибки валидации данных, мы показываем статусное сообщение и указываем пользователю, что найдено ошибки в форме;
* если студент успешно добавлен, показываем сообщение на странице со списком студентов;
* если нажата кнопка "Отмена", показываем сообщение, что изменения отменено.

Реализуем данные сообщения своими силами. Для этого используем давно забытый виджет "alert", который мы настроили по [Twitter Bootstrap Алерт] (http://getbootstrap.com/components/#alerts).

Вот найден и раскомментирован "alert" элемент в шаблоне base.html:

{title="Статусное сообщение в base.html шаблоне",lang="html"}
~~~~~~~~
    <!-- Start Content Columns -->
    <div class="row" id="content-columns">
      <div class="col-xs-12" id="content-column">

        <div class="alert alert-warning" role="alert">Статусное сообщение</div>

        <h2>{% block title %}{% endblock title %}</h2>
        {% block content %}{% endblock content %}

      </div>
    </div>
    <!-- End Content Columns -->
~~~~~~~~

В 5й строке, как видите, у нас есть "статусное сообщение". Но пока оно только статическое и постоянно показываться на странице.

Самым простым подходом, чтобы передавать сообщения между страницами при редиректе, будет использование URL параметров. Большинство запросов будут типа GET, соответственно, можем проверять присутствие параметра в запросе. Если да - показываем наше сообщение, а значение параметра вставляем внутрь тега алерт:

{title="Статусное сообщение в base.html шаблоне",lang="html"}
~~~~~~~~
    <!-- Start Content Columns -->
    <div class="row" id="content-columns">
      <div class="col-xs-12" id="content-column">

        {% block status_message %}
        {% if request.GET.status_message %}
        <div class="alert alert-warning" role="alert">{{ request.GET.status_message }}</div>
        {% endif %}
        {% endblock %}

        <h2>{% block title %}{% endblock title %}</h2>
        {% block content %}{% endblock content %}

      </div>
    </div>
    <!-- End Content Columns -->
~~~~~~~~

Как видите, переменную, в которую передаем статусное сообщение мы назвали "status_message". Если данная переменная присутствует в запросе ("request.GET"), тогда показываем элемент с алерт, а значение этой переменной вставляем внутри тега. Кроме того, заметьте, что алерт является теперь обернутым в именуемый блок "status_message". Это нам пригодится позже, когда надо будет по другому вставлять данное сообщение на тех страницах, где у нас нет редиректа. В частности, на странице с формой добавления студента, когда валидация данных не проходит.

Теперь, когда наши шаблоны готовы к отображению сообщений осталось научить наши вьюшки редиректить на страницы и при этом передавать дополнительный параметр "status_message".

Начнем с редиректов, происходящих при успешном добавлении студента и при нажатии кнопки Отменить:

{title="Добавляем status_message к вьюшке students_add",lang="python"}
~~~~~~~~
def students_add(request):
    # was form posted?
    if request.method == "POST":
        # was form add button clicked?
        if request.POST.get('add_button') is not None:
            # errors collection
            errors = {}

            # data for student object
            data = {'middle_name': request.POST.get('middle_name'),
                    'notes': request.POST.get('notes')}

            # validate user input
            first_name = request.POST.get('first_name', '').strip()
            if not first_name:
                errors['first_name'] = u"Имя обязательно"
            else:
                data['first_name'] = first_name

            last_name = request.POST.get('last_name', '').strip()
            if not last_name:
                errors['last_name'] = u"Фамилия обязательна"
            else:
                data['last_name'] = last_name

            birthday = request.POST.get('birthday', '').strip()
            if not birthday:
                errors['birthday'] = u"Дата Рождения обязательна"
            else:
                try:
                    datetime.strptime(birthday, '%Y-%m-%d')
                except Exception:
                    errors['birthday'] = \
                        u"Введите корректный формат даты (напр. 1984-12-30)"
                else:
                    data['birthday'] = birthday

            ticket = request.POST.get('ticket', '').strip()
            if not ticket:
                errors['ticket'] = u"Номер билета обязательный"
            else:
                data['ticket'] = ticket

            student_group = request.POST.get('student_group', '').strip()
            if not student_group:
                errors['student_group'] = u"Выберете группу для студента"
            else:
                groups = Group.objects.filter(pk=student_group)
                if len(groups) != 1:
                    errors['student_group'] = u"Выберете корректную группу"
                else:
                    data['student_group'] = groups[0]


            photo = request.FILES.get('photo')
            if photo:
                data['photo'] = photo

            # save student
            if not errors:
                student = Student(**data)
                student.save()

                # redirect to students list
                return HttpResponseRedirect(
                    u'%s?status_message=Студент успешно добавлен!' %
                    reverse('home'))
            else:
                # render form with errors and previous user input
                return render(request, 'students/students_add.html',
                    {'groups': Group.objects.all().order_by('title'),
                     'errors': errors})
        elif request.POST.get('cancel_button') is not None:
            # redirect to home page on cancel button
            return HttpResponseRedirect(
                u'%s?status_message=Добавление студента отменено!' %
                reverse('home'))
    else:
        # initial form render
        return render(request, 'students/students_add.html',
            {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

Я привел полный код функции вьюшки добавления студента. Но изменены были только две строки:

* 70я: к HttpResponseRedirect строке добавили "? Status_message = Студент успешно добавлен!"; сделали мы это с помощью интерполяций строк в языке Python;
* 80я: таким же образом мы добавили сообщение при нажиме кнопки Отмена.

A> На домашнее задание: добавьте к статусному сообщению об успешном создании студента еще и полное имя созданного объекта.

Вот как будет выглядеть сообщение об отменено добавления студента:

![Статусное сообщение](images/status_message.jpg)

Остался еще один сценарий: статусное сообщение о найденных ошибках в форме. Это несколько более сложная ситуация, ведь при неправильных данных мы не делаем редиректа, соответственно, и не можем установить URL параметр.

Сделайте паузу и подумайте как бы вы реализовали данное сообщение ...

А теперь смотрите, какой вариант я предлагаю использовать. Мы уже обернули наше статусное сообщение в тег блока, поэтому можем его полностью перекрывать в конечном шаблоне. Это мы и сделаем в шаблоне students_add.html. В данном шаблоне мы также имеем доступную переменную "errors", согласно которой можем определять показывать сообщение или нет. А именно сообщение можем вписать статическим текстом, ведь оно всегда будет иметь единственную причину: ошибки на форме. Добавьте следующий блок где-нибудь в шаблоне students_add.html на корневом уровне:

{title="Добавляем статусное сообщение для формы добавления студента",lang="html"}
~~~~~~~~
{% block status_message %}
  {% if errors %}
  <div class="alert alert-warning" role="alert">
    Пожалуйста, исправьте следующие ошибки
  </div>
  {% endif %}
{% endblock status_message %}
~~~~~~~~

Думаю дополнительных объяснений здесь не требуется. Таким образом реализовали все три сценария со статусными сообщениями.

A> На домашнее задание предлагаю вам переделать статусные сообщения с использованием встроенного Django приложения "django.contrib.messages". Они специально предназначены для данной задачи и предоставляют как серверную логику, так и тег для шаблонов, чтобы с легкостью и гибко отображать статусные сообщения. Самое распространенное их применения - это работа с формами.

### Стили Twitter Bootstrap

В завершение данной секции приведем нашу форму добавления студента к хорошему виду. Как всегда, воспользуемся стилями с замечательного фреймворка [Twitter Bootstrap] (http://getbootstrap.com/css/#forms).

У нас есть несколько требований к виду формы:

* увеличить вертикальные расстояния между полями формы;
* подровнять метки и поля между собой;
* сделать ширину полей одинаковой;
* форма должна менять ширину в соответствии с шириной окна браузера; то есть хорошо выглядеть и на рабочем столе, и на мобильном;
* метки должны быть в одной строке с полями;
* сообщения об ошибках должны быть красного цвета, сигнализируя, таким образом, об ошибке;
* кнопку Добавить сделать темно синей, а кнопку Отменить в виде ссылки.

Для начала по-максимуму воспользуемся шаблонами Twitter Bootstrap форм и добавим все необходимые классы и элементы-обертки нашей форме:

* "form-horizontal" класс к тегу form;
* "form-control" класс для всех полей формы;
* "form-group" к обреткам div елементов наших полей;
* также к "form-group" классу добавим "has-error" класс в случае, если в поле ошибка при валидации;
* к меткам (тег "label") добавляем класс "control-label";
* также к меткам добавляем позиционный класс "col-sm-2", указав занимать им 2 части из 12-ти;
* а 10 частей будет занимать поля; для этого обернем наши теги полей (теги input, select, textarea) та тег с ошибкой "span.help-block" в дополнительный тег div, которому присвоим класс "col-sm-10";
* класси "btn" и "btn-primary" к кнопке "Добавить"; это придаст ей хорошего синего цвета и дефолтных стилей библиотеки;
* класси "btn" и "btn-link" к кнопке "Отменить"; после этого она будет выглядеть как ссылка; это неплохо подходит для кнопок с отменами действий.

Ничего своего мы не придумывали, а лишь взяли классы из Twitter Bootstrap стилей для форм и добавили к нашим тегам. Вот конечный результат обновленной формы:

{title="Наша форма с Twitter Bootstrap стилями",lang="html"}
~~~~~~~~
<form action="." method="post" enctype="multipart/form-data"
      role="form" class="form-horizontal">
  {% csrf_token %}

  <div class="form-group {% if errors.first_name %}has-error{% endif %}">
    <label for="first_name" class="col-sm-2 control-label">Ім'я*</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.first_name }}"
             name="first_name" id="first_name"
             class="form-control" />
      <span class="help-block">{{ errors.first_name }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.last_name %}has-error{% endif %}">
    <label for="last_name" class="col-sm-2 control-label">Прізвище*</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.first_name }}"
             name="last_name" id="last_name"
             placeholder="Введите вашу фамилию"
             class="form-control" />
      <span class="help-block">{{ errors.last_name }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.middle_name %}has-error{% endif %}">
    <label for="middle_name"class="col-sm-2 control-label">По-батькові</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.first_name }}"
             name="middle_name" id="middle_name"
             class="form-control" />
      <span class="help-block">{{ errors.middle_name }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.birthday %}has-error{% endif %}">
    <label for="birthday"class="col-sm-2 control-label">Дата Народження*</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.birthday }}"
             name="birthday" id="birthday"
             placeholder="Напр. 1984-12-30"
             class="form-control" />
      <span class="help-block">{{ errors.birthday }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.photo %}has-error{% endif %}">
    <label for="photo"class="col-sm-2 control-label">Фото</label>
    <div class="col-sm-10">
      <input type="file" value="" name="photo" id="photo"
             class="form-control" />
      <span class="help-block">{{ errors.photo }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.ticket %}has-error{% endif %}">
    <label for="ticket"class="col-sm-2 control-label">Білет*</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.ticket }}"
             name="ticket" id="ticket"
             class="form-control" />
      <span class="help-block">{{ errors.ticket }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.student_group %}has-error{% endif %}">
    <label for="student_group"class="col-sm-2 control-label">Група*</label>
    <div class="col-sm-10">
      <select name="student_group" id="student_group"
              class="form-control">
        <option value="">Виберите группу</option>
        {% for group in groups %}
        <option value="{{ group.id }}" {% if group.id == request.POST.student_group|add:0 %}selected="1"{% endif %}>{{ group.title }}</option>
        {% endfor %}
      </select>
      <span class="help-block">{{ errors.student_group }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.notes %}has-error{% endif %}">
    <label for="notes" class="col-sm-2 control-label">Дополнительные Заметки</label>
    <div class="col-sm-10">
      <textarea name="notes" id="notes" class="form-control">{{ request.POST.notes }}</textarea>
      <span class="help-block">{{ errors.notes }}</span>
    </div>
  </div>
  <div class="form-group">
    <label class="col-sm-2 control-label"></label>
    <div class="col-sm-10">
      <input type="submit" value="Добавить" name="add_button"
             class="btn btn-primary" />
      <button type="submit" name="cancel_button"
              class="btn btn-link">Отменить</button>
    </div>
  </div>
</form>
~~~~~~~~

Обратите внимание на строку под номером 5. Там мы вставляем класс "has-error" только при наличии ошибки с полем Имя. Подобную вещь мы проделали для всех полей, чтобы иметь дополнительные стили ошибки для тех полей, которые не прошли валидацию данных.

Обновите страницу в браузере и посмотрите стили формы и стили сообщений с ошибками. Осталась одна вещь: поля формы растянуты на всю ширину страницы. Это может быть неплохим подходом на узких экранах, но на широких такие поля выглядят слишком широкими.

Данную проблему мы довольно просто решим самостоятельно собственным CSS кодом:

{title="Обновляем стили нашей формы, файл main.css",lang="css"}
~~~~~~~~
/* Form Styles */
textarea,
select,
input {
  max-width: 300px;
}
~~~~~~~~

Стилей довольно немного. Все, что мы сделали это: установили максимальную ширину всех полей до 300 пикселей. Таким образом мы не обрезали классного функционала Twitter Bootstrap, который делает нашу форму красивой на всех ширину экрана, а лишь ограничили по максимальной ширине.

Опять обновите страницу с формой. Вот конечный результат наших стараний:

![Форма добавления студента полностью завершена](images/student_add_form_styled.jpg)

A> И не забывайте о регулярных коммитах в репозиторий кода.

Хорошая работа! Перед тем как переходить к следующей секции предлагаю сделать небольшую паузу и поэкспериментировать с материалом данной секции. Ведь здесь мы разобрались с основами работы с формами. Далее мы с вами продолжим строить формы, но с каждой новой секцией данной главы все больше и больше работы за нас будет делать фреймворк Django.

## Форма контакта с администратором

Мы не сразу перейдем от полностью ручной формы добавления студента к полностью автоматической, построенной с помощью Django форм моделей.

Чтобы лучше понять механизм построения автоматически сгенерированной формы, сначала реализуем форму контакта с администратором сайта. Ее мы построим на отдельной закладке нашего приложения "Контакт" и она позволит пользователям отправлять письма администратору.

Для этого мы воспользуемся Django классом для формы. Этот класс для нас:

* сгенерирует HTML код полей формы;
* сделает валидацию полей согласно правилам, на которые мы ему укажем.

Нам останется только получить уже корректные данные и отправить письмо по почте.

### Подключаем новую закладку

Начнем с построения инфраструктуры для нашей новой страницы с формой контакта.

В urls.py модуль добавим новый шаблон, который будет обслуживать нашу страницу:

{title="URL адрес для формы контакта, urls.py модуль",lang="python"}
~~~~~~~~
    # Contact Admin Form
    url(r'^contact-admin/$', 'students.views.contact_admin.contact_admin',
        name='contact_admin'),
~~~~~~~~

Как видно из нового URL шаблона, нам нужно добавить новый модуль contact_admin.py в пакете views приложения students, а в модуле добавить новую функцию-вьюшку contact_admin:

{title="Создаем модуль contact_admin.py",lang="shell"}
~~~~~~~~
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/views
$ touch contact_admin.py
~~~~~~~~

Добавляем базовый код вьюшки, который, пока что возвращает только шаблон form.html. Данный шаблон будет лежать в подпапке contact_admin внутри папки с шаблонами:

{title="contact_admin вьюшка",lang="python"}
~~~~~~~~
from django.shortcuts import render

def contact_admin(request):
    return render(request, 'contact_admin/form.html', {})
~~~~~~~~

Соответственно, теперь нужно создать шаблон form.html, а еще лучше, скопировать его из существующих шаблонов:

{title="Копируем шаблон students/students_add.html в contact_admin/form.html",lang="shell"}
~~~~~~~~
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/templates
$ mkdir contact_admin
$ cp students/students_add.html contact_admin/form.html
~~~~~~~~

Отредактируем шаблон form.html, а блок content оставим практически пустым, пока что:

{title="База для шаблона с формой, form.html",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}

{% block meta_title %}Связь с Администратором{% endblock meta_title %}

{% block title %}Связь с Администратором{% endblock title %}

{% block content %}

Здесь будет форма контакта.

{% endblock content %}
~~~~~~~~

В завершение построения инфраструктуры новой страницы, внутри шаблона base.html, добавим новую закладку Контакт

{title="Добавляем закладку Контакт",lang="html"}
~~~~~~~~
        <ul class="nav nav-tabs" role="tablist">
          <li role="presentation" {% if request.path == '/' %}class="active"{% endif %}><a href="{% url "home" %}">Студенти</a></li>
          <li role="presentation" {% if '/journal' in request.path %}class="active"{% endif %}><a href="/journal">Відвідування</a></li>
          <li role="presentation" {% if '/groups' in request.path %}class="active"{% endif %}><a href="{% url "groups" %}">Групи</a></li>
          <li role="presentation" {% if '/contact-admin' in request.path %}class="active"{% endif %}><a href="{% url "contact_admin" %}">Контакт</a></li>
        </ul>
~~~~~~~~

Обратите внимание, что в теге "url" мы воспользовались именем URL шаблона, который ранее прописали в модуле urls.py.

Вроде все. Перегружайте смело вашу страницу в браузере. Должна появиться закладка Контакт, которая покажет пустую страницу с заголовком: "Связь с администратором".

Теперь мы готовы к реализации самой формы.

### Класс форми

Автоматические формы в Django строим подобно тому, как реализовали классы моделей. Нам нужно определить класс нашей формы, унаследовать от правильного базового класса и наполнить класс списком необходимых полей.

A> Автоматическими называем те формы, которые генеруеють HTML код и предоставляют всю валидацию данных без дополнительного кастомного кода со стороны разработчика.

Вот пример нашей формы контакта со всеми необходимыми для нее полями. Весь код класса формы, как и самой вьюшки, помещаем в contact_admin.py модуль:

{title="Класс формы контакта администратора",lang="python"}
~~~~~~~~
from django import forms

class ContactForm(forms.Form):
    from_email = forms.EmailField(
        label=u"Ваш Емейл Адрес")

    subject = forms.CharField(
        label=u"Заголовок письма",
        max_length=128)

    message = forms.CharField(
        label=u"Текст сообщения",
        max_length=2560,
        widget=forms.Textarea)
~~~~~~~~

Как видите мы создали класс ContactForm, который наследуется с базового класса Form. Данный класс приходит из встроенного в Django пакета: "django.forms". Все, что связано с формами лежит в данном пакете.

Далее в классе идет список полей, которые нужны нам на форме контакта:

* емейл адрес отправителя
* заголовок письма;
* и само тело сообщения.

Декларация полей аналогична с тем, как мы набивали поля для классов моделей студента и группы. Но в данном случае мы используем классы полей, приходят, опять же, с пакета "django.forms". Эти поля немного отличаются от тех, что есть моделях. [Здесь] (http://djbook.ru/rel1.7/ref/forms/fields.html) можно просмотреть как сопоставляются данные поля с полями моделей, а также список доступных полей форм.

Каждое поле имеет ряд аргументов для влияния на то, как поле будет выглядеть в форме, какой тип данных будет соответствовать данному полю, какая валидация применяться на сервере. Таким образом мы указали, что хотим иметь Textarea виджет для поля "Текстовое сообщение". Это для того, чтобы пользователь мог отправлять целые параграфы текста в письме. Также можете видеть, что мы воспользовались специальным полем для емейл адреса отправителя. Данное поле за нас сделает валидацию на корректный формат емейл адреса.

Кроме генерации HTML кода формы и валидации данных, данный класс формы также преобразует данные, пришедшие от пользователя в теле поста, в Python типа. Таким образом нам не придется делать это самим.

Если чувствуете, что нуждаетесь немного больше в теории по Django формах, тогда рекомендую ознакомиться с [официальным введением в формы](http://djbook.ru/rel1.7/topics/forms/index.html).


### Логика отправки письма

Имея заготовку шаблона и готовый класс формы контакта, можем приступать к реализации интересной части нашей задачи - логика вьюшки по отправке письма.

Сразу скажу вам, что кода будет значительно меньше, чем мы писали для формы добавления студента, ведь всю валидацию и форматирование данных для нас сделает класс формы. Вот как будет выглядеть конечный код модуля contact_admin.py:

{title="Законченая вьюшка отправки емэйла админу",lang="python"}
~~~~~~~~
# -*- coding: utf-8 -*-
from django.shortcuts import render
from django import forms
from django.core.mail import send_mail
from django.http import HttpResponseRedirect
from django.core.urlresolvers import reverse

from studentsdb.settings import ADMIN_EMAIL

class ContactForm(forms.Form):
    from_email = forms.EmailField(
        label=u "Ваш Емейл Адрес")

    subject = forms.CharField(
        label=u"Заголовок письма",
        max_length=128)

    message = forms.CharField(
        label=u"Текст сообщения",
        widget=forms.Textarea)

def contact_admin(request):
    # check if form was posted
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ContactForm(request.POST)

        # check whether user data is valid:
        if form.is_valid():
            # send email
            subject = form.cleaned_data['subject']
            message = form.cleaned_data['message']
            from_email = form.cleaned_data['from_email']

            try:
                send_mail(subject, message, from_email, [ADMIN_EMAIL])
            except Exception:
                message = u'Во время отправки письма возникла непредвиденная ' \
                    u'ошибка. Попробуйте воспользоваться данной формой позже.'
            else:
                message = u'Сообщение успешно отправлено!'

            # redirect to same contact page with success message
            return HttpResponseRedirect(
                u'%s?status_message=%s' % (reverse('contact_admin'), message))

    # if there was not POST render blank form
    else:
        form = ContactForm()

    return render(request, 'contact_admin/form.html', {'form': form})
~~~~~~~~

Нас интересует только функция вьюшки:

* 24я: с этим мы уже сталкивались ранее; проверяем была ли форма отправлена ​​POST запросом;
* 27я: создаем объект из класса формы, при этом передавая ему POST в качестве аргумента; таким образом получим "привязанную" (англ. bound) форму с данными введенными пользователем; это позволит форме валидировать и конвертировать данные, а позже отобразить эти данные на форме при неудачной валидации;
* 30я: по-настоящему волшебная строка кода :-); вызов метода is_valid () на объекте формы заменяет нам всю валидацию данных, а также конвертацию данных в Python типы данных; данный метод возвращает True, если валидация данных прошла успешно, False - в противном случае;
* 32я: метод is_valid () "помещает" все конвертируемые данные с POST запроса в атрибут "cleaned_data"; лучше использовать данные из него, чем напрямую с "request.POST", ведь там они уже правильно подготовленные для нашего использования; таким образом получаем заголовок письма и сохраняем его в переменную; аналогично делаем с остальными полями формы;
* 36я: начинаем самое интересное - отправку письма; данная процедура может выбросить различные ошибки при контакте с сервером, отправляет письма, поэтому стоит окружить следующй код веткой "try/except";
* 37я: в начале модуля мы импортнули функцию send_mail с пакета "django.core.mail"; теперь мы воспользуемся данной функцией; она принимает следующие аргументы в следующем порядке: заголовок письма, тело письма, email адрес отправителя, список получателей; адрес получателя мы импортнули с модуля settings.py проекта; дальше мы настроим емейл сервер, а также добавим данную переменную ADMIN_EMAIL к настройкам; эта функция является надстройкой над Python функцией и облегчает работу по отправке емейл; также она считывает настройки из модуля проекта для нас,
* 39я: в случае, если функция send_email сломалась при попытке отправки письма, мы перехватываем все ошибки и устанавливаем соответствующее статусное сообщение о поломке; данное сообщение мы дальше используем при редиректе;
* 44я: если же отправка прошла успешно (да, "try/except" имеют еще и ветку "else"), мы также устанавливаем статусное сообщение, но теперь о положительном результате отправки письма;
* 48я: независимо от результата мы редиректим обратно на форму контакта, при этом показывая статусное сообщение установленое ранее;
* 53я: начинаем ветку кода, когда метов формы не POST;
* 54я: в таком случае мы также создаем объект из класса формы, но на этот раз не передаем ему данные из запроса; таким образом форма будет пустой на странице;
* 56я: отдаем шаблон страницы, передавая объект формы.

Заметьте: если форма будет отрпавлена, но данные не будут проходить валидацию, тогда в шаблон мы передадим "привязанную" форму (то есть форму с данными из предыдущего запроса). Таким образом, при неправильно введенных данных, пользователь получит заполненные поля и сможет исправить ошибки без повторного ввода всех полей.

Теперь, когда вся логика функции вьюшки на месте, нужно сделать еще две вещи, чтобы заставить это все заработать:

* настроить сервер отправки емейлов;
* обновить шаблон, чтобы использовал переданную ему форму, а также правильно отражал статусные сообщения.

### SMTP сервер отправки писем

Данная секция не включает детальную настройку самого SMTP сервера (сервера по отправке писем), а лишь предоставляет обзор нескольких вариантов отправки писем. Здесь мы сфокусируемся на том, как и где правильно прописать детали вашего сервера в коде нашего Django проекта.

A> Задача по настройке собственного SMTP сервера остается вам на самостоятельную проработку.

Функция send_mail, которую мы используем для отправки писем, требует нескольких настроенных переменных в модуле settings.py проекта:

* EMAIL_HOST: адрес вашего SMTP сервера;
* EMAIL_PORT: порт SMTP сервера;
* EMAIL_HOST_USER: имя пользователя, если доступ к серверу закрыт;
* EMAIL_HOST_PASSWORD: пароль пользователя, если доступ к серверу закрыт;
* EMAIL_USE_TLS: использовать безопасное TLS соединения при контакте SMTP сервера или нет; это зависит от типа сервера и его настроек;
* EMAIL_USE_SSL: взаимоисключающая опция с EMAIL_USE_TLS; если одна из них включена, тогда другое обязательно должна быть исключена; если не уверены, какой именно режим безопасности работает на вашем SMTP сервере - пробуйте различные комбинации переключения данных опций, а также вариант, когда обе выключены.

Также в settings.py нужно добавить переменную ADMIN_EMAIL, которая будет указывать на емейл адрес администратора нашего веб-приложения:

{title="Пример настройки SMTP сервера",lang="python"}
~~~~~~~~
# email settings
# please, set here you smtp server details and your admin email
ADMIN_EMAIL = 'admin@studentsdb.com'
EMAIL_HOST = 'smtp.server.com'
EMAIL_PORT = '587'
EMAIL_HOST_USER = 'username1'
EMAIL_HOST_PASSWORD = '********'
EMAIL_USE_TLS = True
EMAIL_USE_SSL = False
~~~~~~~~

В зависимости от того, как настроите ваш SMTP сервер (или каким внешним сервером воспользуетесь), так придется обновить значение данных переменных.

Есть как минимум три варианта для отправки писем:

**Воспользоваться SMTP сервером вашего почтовика**

Если у вас, например, есть аккаунт на gmail.com, тогда вы можете воспользоваться им для отправки писем с нашей аппликации.

На [этой странице](http://ru.email-unlimited.com/help/mailer/smtp-settings-samples.html) вы можете найти детали доступа и использования Gmail SMTP сервера, а также других популярных емейл сервисов.

Вот пример моих настроек в случае использования Gmail сервера для отправки писем:

{title="Пример настройки для Gmail SMTP сервера",lang="python"}
~~~~~~~~
# email settings
# please, set here you smtp server details and your admin email
ADMIN_EMAIL = 'admin@studentsdb.com'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = '465'
EMAIL_HOST_USER = 'vitaliypodoba@gmail.com'
EMAIL_HOST_PASSWORD = '********'
EMAIL_USE_TLS = False
EMAIL_USE_SSL = True
~~~~~~~~

**Специализированный сервис отправки писем**

Также существует масса внешних сервисов для отправки писем. Они предоставляют SMTP сервер для использования и, так же как и с вашим почтовиком, вам остается только добавить детали сервера в модуль настройки проекта.

Я рекомендую посмотреть следующие сервисы:

* https://mandrillapp.com - пользуюсь им больше других в данный момент;
* https://sendgrid.com/ - один из самых популярных сервисов рассылки писем на данный момент;
* http://www.icontact.com/ - еще один неплохой сервис отправки писем.

Зарегистрируйтесь на одном из них. Отправка небольшого количества емейл обычно является бесплатным. Для тестирования точно хватит. После регистрации настройте сервис и получите данные доступа к его SMTP серверу.

Вот как будет выглядеть пример моих настроек через сервис Mandrill:

{title="Пример настройки для Mandrill SMTP сервера",lang="python"}
~~~~~~~~
# email settings
# please, set here you smtp server details and your admin email
ADMIN_EMAIL = 'admin@studentsdb.com'
EMAIL_HOST = 'smtp.mandrillapp.com'
EMAIL_PORT = '587'
EMAIL_HOST_USER = 'vitaliypodoba@gmail.com'
EMAIL_HOST_PASSWORD = '********'
EMAIL_USE_TLS = True
EMAIL_USE_SSL = False
~~~~~~~~

**Собственный SMTP сервер**

В конце концов можете попробовать установить и настроить собственный SMTP сервер на локальной машине.

На Линуксе одними из самых популярных есть [sendmail] (http://uk.wikipedia.org/wiki/Sendmail) и [postfix] (http://uk.wikipedia.org/wiki/Postfix).

Если действительно хотите попробовать данный вариант, тогда инсталляция и конфигурация данных серверов полностью остается вам на самостоятельную проработку.

После успешной настройки собственного SMTP сервера ваш settings.py модуль должен содержать что-то подобное:

{title="Пример настройки локального SMTP сервера",lang="python"}
~~~~~~~~
# email settings
# please, set here you smtp server details and your admin email
ADMIN_EMAIL = 'admin@studentsdb.com'
EMAIL_HOST = 'localhost'
EMAIL_PORT = '25'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_USE_TLS = False
EMAIL_USE_SSL = False
~~~~~~~~

Думаю вы не будете настраивать ни доступ по пользователю, ни безопасные протоколы.

C> ...

[Здесь](http://djbook.ru/rel1.7/ref/settings.html#email-host) можете найти больше деталей о конфигурации настроек для сервера отправки писем.

А на [этой странице](http://djbook.ru/rel1.7/topics/email.html) есть неплохе вступление по работе с письмами в Django.

Если все сделали правильно, то за 30 минут получите код по отрпавке писем.

### Обновляем шаблон формы

Осталось совсем немного, чтобы закончить с отправкой писем: обновить шаблон, где воспользоваться формой, которую нам передает вьюшка.

Нам нужно обновить два блока: content и status_message. И начнем мы с более важного - блока content.

Объект формы предоставляет нам несколько полезных методов для генерации HTML кода формы:

* {{ form.as_p }}: оборачивает поля (метку + поле ввода) в теги параграфов (p)
* {{ form.as_table}} представляет форму в виде таблицы;
* {{ form.as_ul}} представляет поля в виде списка (теги "ul / li")
* ну и на конец: если вставить объект формы в шаблон без использования Вышеперечисленные методов, тогда теги полей не будут окружены ни в какие дополнительные теги.

Еще хочу обратить ваше внимание на то, что форма не сгенерирует для нас самого тега формы и кнопок, а только HTML код для списка полей задекларированных в классе формы. Так же тег CSRF защиты нужно вставить самостоятельно. Вот конечный результат блока content:

{title="Добавляем форму контакта, contact_admin.form.html",lang="html"}
~~~~~~~~
{% block content %}

<form action="{% url "contact_admin" %}" method="post">
    {% csrf_token %}

    {{ form.as_p }}

    <input type="submit" value="Отправить" name="send_button" />
</form>

{% endblock content %}
~~~~~~~~

Метод запроса формы POST, а ссылается форма сама на себя, ведь наша вьюшка занимается как генерацией формы, так и ее обработкой.

Все остальные, думаю, для вас понятно.

Уже сейчас форма должна быть полностью рабочей. Статусные сообщения об успешной отправке и поломке при попытке отправить письмо также уже должны работать. Попробуйте потестировать функционал формы. Если получаете ошибку при попытке отправить валидные данные, возвращайтесь в секцию по настройке SMTP сервера и попробуйте починить значения переменных в модуле settings.py.

Но есть еще один должок по функционалу формы. В случае, если данные не прошли валидацию, мы получаем ошибки сверху некорректно введенных полей, но нет глобального статусного сообщения.

Для этого нам нужно полностью перекрыть блок status_message, что приходит с шаблона base.html под нужды нашей формы:

{title="Перекрывает блок status_message",lang="html"}
~~~~~~~~
{% block status_message %}

{% if form.errors %}
  <div class="alert alert-warning" role="alert">
    Пожалуйста, исправьте следующие ошибки
  </div>
{% endif %}

{{ block.super }}

{% endblock %}
~~~~~~~~

Что мы сделали?

* 3я: все собранные ошибки при валидации данных от пользователя форма для нас собирает в атрибут errors; поэтому мы воспользовались им, чтобы проверить прошла ли форма валидацию;
* 4я: если есть ошибки, то есть валидация не прошла, выводим статическое сообщение и просим пользователя исправить их;
* 9я: block.super - интересный момент; нам нужен кусок кода, который будет выводить статусные сообщения, которые мы передаем во время редиректа в URL параметре status_message; и чтобы не дублировать код с base.html, мы вставляем его в конечный шаблон через "block.super"; атрибут "super" указывает на родительский блок, который в нашем случае является блоком с шаблона base.html.

A> Обратите внимание на то, что автоматические сообщения об ошибках на форме есть уже переведенными на украинский язык. Это благодаря прописанной переменной "LANGUAGE_CODE = 'uk'" в модуле settings.py. Для русского языка, необходимо изменить значение на: "LANGUAGE_CODE = 'ru'". Django формы уже имеют украинский(русский) перевод интерфейса форм по-умолчанию. Позже мы вернемся к этой теме и полностью переведем наше приложение на украинский(русский) язык правильным способом.

Обновите форму и еще раз потестуйте ее. Весь функционал на месте! Вот как будет выглядеть ваша форма в случае, если произойдет ошибка при валидации данных:

![Форма контакта администратора практически готова](images/contact_admin_form.jpg)

Единственное, что осталось это добавить хорошие стиле.

### Стили Twitter Bootstrap через Crispy Forms приложение

Остался только внешний вид формы. А именно:

* подровнять метки и поля;
* стилизировать состояния с ошибками в полях;
* стилизировать кнопку.

Стили опять же возьмем из библиотеки Twitter Bootstrap. Но на этот раз мы имеем далеко не полный контроль над HTML кодом формы. Следовательно нужен другой подход для стилизации.

Воспользуемся одним из существующих Django приложений, которые надписывают HTML стандартных Django форм кодом, который подходит под Twitter Bootstrap правила. Хорошим балансом между функционалом и простотой в использовании обладает приложение [Crispy Forms](https://readthedocs.org/projects/django-crispy-forms/). Им мы и воспользуемся, чтобы "облагородить" нашу форму контакта.

Согласно [инсталляционной документации] (http://django-crispy-forms.readthedocs.org/en/1.2.1/install.html) пакета подключим Crispy Forms к нашему проекту. Будем использовать последнюю стабильную версию - 1.4.0. Хотя она и не упомянута в документации, но я нашел ее среди тегов в [репозитории кода] (https://github.com/maraujop/django-crispy-forms/tree/1.4.0). Соответственно, часть вещей вам придется вычитывать из кода, поскольку кое-что может быть не включен в устаревшую документацию приложения.

Добавим пакет версии 1.4.0 в requirements.txt и установим его в нашу рабочую среду:

{title="requirements.txt",lang="shell"}
~~~~~~~~
Django==1.7.1
MySQL-python
Pillow
django-crispy-forms==1.4.0
~~~~~~~~

{title="Запускаем инсталляцию пакетов",lang="shell"}
~~~~~~~~
# не забудьте перед данной командой активировать свою
# виртуальную среду
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb
$ pip install -r requirements.txt
~~~~~~~~

Добавляем пакет crispy_forms в список установленых приложений:

{title="Добавляем crispy_forms к INSTALLED_APPS внутри settings.py модуля",lang="python"}
~~~~~~~~
INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'crispy_forms',
    'students',
)
~~~~~~~~

Конфигурируем настройки нового приложения:

{title="settings.py",lang="python"}
~~~~~~~~
CRISPY_TEMPLATE_PACK = 'bootstrap3'
~~~~~~~~

Переменная "CRISPY_TEMPLATE_PACK" указывает приложению Crispy Forms, какие именно шаблоны использовать, ведь она содержит не один набор для различных фреймворков. Нам, конечно, нужен последний Twitter Bootstrap: "bootstrap3".

Подключать CSS i Javascript файлы не будем, ведь они у нас уже давно подключены.

Теперь мы дошли до самой интересной части - будем добавлять стили в форму. Но будем это делать несколько необычным образом: через Python код в классе формы, а не в шаблоне или main.css файле.

Crispy Forms дает нам два типа объектов для воздействия на вид формы:

* [FormHelper класс] (http://django-crispy-forms.readthedocs.org/en/latest/form_helper.html): собственно из-за него мы будем делать все наши изменения; его мы создадим в \_\_init\_\_.py методе класса формы;
* [лэйауты] (http://django-crispy-forms.readthedocs.org/en/latest/layouts.html): они позволяют изменять теги и поля на форме, а также, например, добавлять кнопки на форму (ведь по- умолчанию форма будет без кнопок) нам нужен только один лэйаута - леайут кнопки.

Вот как будет выглядеть обновленный класс формы:


{title="Класс формы с crispy forms FormHelper объектом",lang="python"}
~~~~~~~~
from crispy_forms.helper import FormHelper
from crispy_forms.layout import Submit

class ContactForm(forms.Form):

    def __init__(self, *args, **kwargs):
        # call original initializator
        super(ContactForm, self).__init__(*args, **kwargs)

        # this helper object allows us to customize form
        self.helper = FormHelper()

        # form tag attributes
        self.helper.form_class = 'form-horizontal'
        self.helper.form_method = 'post'
        self.helper.form_action = reverse('contact_admin')

        # twitter bootstrap styles
        self.helper.help_text_inline = True
        self.helper.html5_required = True
        self.helper.label_class = 'col-sm-2 control-label'
        self.helper.field_class = 'col-sm-10'

        # form buttons
        self.helper.add_input(Submit('send_button', u'Надіслати'))
~~~~~~~~

В данном примере мы не приводили список полей, ведь они остались неизменными.

Давайте подробнее по-строках проанализируем метод \_\_init\_\_.py:

* 1я: импортируем необходимый минимум классов с crispy_forms приложения; Submit - лэйаут кнопки, которым мы дальше в коде воспользуемся;
* 11я: создаем объект типа FormHelper и запоминаем его в атрибуте "helper" объекта формы; важно, чтобы атрибут имел именно данное название, тогда Crispy Forms шаблонный тег подхватит нашего хелпера автоматически;
* 13я: блок кода, где мы модифицируем сам тег формы, устанавливая ему класс, метод и атрибут 'action'; так, Crispy Forms сгенерирует для нас полную форму, включая тегом form, CSRF защитой и кнопками; позже мы обновим соответственно наш шаблон;
* 18я: блок кода, где мы устанавливаем специальные атрибуты для Twitter Bootstrap библиотеки, а именно: включаем HTML5 атрибуты валидации и добавляем классы Grid лэйаута для метки и поля, чтобы лучше расположить элементы формы на странице;
* 25я: добавляем из кода лэйаута кнопки Submit; эта строка кода добавит нам кнопку "Отправить" в форму под названием "send_button".

Все, что нужно сделать с изменениями в форме, мы сделали. Теперь нужно обновить наш шаблон, чтобы он показывал не стандартную, а кастомную форму, которая приходит с Crispy Forms HTML кодом.

Именно для этого данне приложение предоставляет тег "{% crispy [form_name]%}", которому нужно передать объект формы. Данный тег сгенерирует полный тег формы со всеми изменениями, которые мы записали в Python коде.

Вот как довольно просто выглядит конечный шаблон:

{title="Шаблон формы использует Crispy Forms",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}
{% load crispy_forms_tags %}

{% block meta_title %}Связь с Администратором{% endblock meta_title %}

{% block title %}Связь с Администратором{% endblock title %}

{% block status_message %}
{% if form.errors %}
  <div class="alert alert-warning" role="alert">
    Пожалуйста, исправьте следующие ошибки
  </div>
{% endif %}

{{ block.super }}
{% endblock %}


{% block content %}

{% crispy form %}

{% endblock content %}

~~~~~~~~

Что мы изменили:

* 4я: загрузили теги с Crispy Forms приложения; по-умолчанию внешние приложения не подключает свои теги в шаблоны;
* 24я: вызвали тег "{% crispy %}" и передали ему нашу форму.

Так просто мы получили конечную форму. Теперь перезагрузите страницу с формой и посмотрите на результат:

![Форма контакта администратора с Crispy Forms](images/contact_admin_from_crispy.jpg)

Как видите, форма уже выглядит значительно лучше. Crispy Forms аппликация на все 100% удовлетворила наши потребности.

A> На домашнее задание: переделайте контакт форму с использованием уже существующего Django приложения: https://pypi.python.org/pypi/django-contact-form По сути, вам практически не придется разрабатывать кастомного кода, а только интегрировать существующий в свое приложение.

C> ...

Теперь мы не только умеем с нуля создавать форму и работать с ней, но и знаем быстрый путь для получения данных от пользователя - Django формы. Будем еще больше ускоряться! Переходим к Django формам созданным специально для работы с моделями.

## Форма редактирования студента

Форма редактирования, пожалуй, будет самой быстрой формой, которую мы реализуем. Без написания HTML кода полей, практически без Python логики, декларации полей и даже класса формы! Все это за нас сделает форма Django для работы с моделями.

Для вьюшки формы редактирования студента мы впервые воспользуемся не функцией, а классом. Поэтому давайте сначала коротко осмотрим разницу между этими двумя подходами, а также когда использовать каждый из них.

### Вьюшки Функции vs вьюшки Классы

Вьюшки Классы ввели в Django относительно недавно. До этого мы могли создавать вьюшки только используя Python функции.

Основной задачей классов является уменьшить дублированный код между вьюшками. Python классы позволяют определять абстрактные классы, в которых будет содержаться повторяющийся код, и затем наследоваться от этих классов в конечных вьюшках.

Программирование веб-сайтов это, достаточно часто, много повторяющейся работы. Именно такую ​​повторяющуюся работу и попытались вынести в заранее заготовленные классы вьюшек в Django. Таким образом, если ваша задача подпадает под категорию таких повторяющихся рутин, тогда вы сможете сэкономить массу времени, воспользовавшись готовым классом.

Вот список определенных для нас классов в Django:

* ListView: для вывода списка объектов из базы;
* DetailView: для отображения одного объекта из базы;
* RedirectView: для осуществления редиректа на другую страницу; даже для этого действия есть отдельная вьюшка-класс;
* CreateView: форма добавления нового объекта в базу;
* UpdateView: форма редактирования существующего объекта в базе;
* DeleteView: удаление объекта из базы;
* ArchiveIndexView, YearArchiveView, MonthArchiveView, WeekArchiveView, DayArchiveView, TodayArchiveView, DateDetailView: вьюшки для реализации страниц блога.

Все вышеперечисленные классы определенным образом используют один из базовых классов: FormView, View, TemplateView. Кстати, классом TemplateView мы сами воспользуемся при реализации закладки Посещение.

**Класс или функция?**

Есть три группы разработчиков в сообществе Django:

* те, кто до последнего избегает классов; то есть всегда начинают с функции, а далее переходят на класс, если уже некуда деваться;
* те, кто пытаются везде "впихнуть" класс;
* те, кто анализирует ситуацию, задачи и проект в целом, и каждый раз решает, что лучше использовать.

Я лично предпочитаю третью группу, и каждый раз выбираю тот подход, который лучше подойдет под конкретную задачу. Вот несколько критериев, которыми я руководствуюсь при этом:

Если ваша задача подпадает под стандартные задачи:

* отразить объект или список объектов из базы данных;
* добавить, отредактировать или удалить объект из базы;
* написать блог,

тогда используйте заранее заготовленные в Django классы вьюшек.

Если вы повторяете много кода в различных функциях вьюшек в проекте, тогда выделите этот код в базовый абстрактный класс, переделайте функции на классы и унаслидуйтесь от базового класса.

Если задача еще не до конца вам понятна, тогда используйте функцию. Позже, при необходимости, переедете на класс.

Если есть вьюшка в виде класса, но со временем кастомизировать ее под нужды проекта становится все труднее и труднее. Тогда есть смысл задуматься над возвращением к функции, где вы будете свободны от каких-либо правил.

Вот и все правила, которыми я обычно руководствуюсь при выборе между классом и функцией для очередной вьюшки. С опытом ваш выбор становиться быстрее и лучшим.

**Работа с классами**

Работа с классами в качестве вьюшек несколько отличается от того, как мы работали с функциями. Классы дают нам много заранее заготовленного функционала, но и вместе с тем много ограничений и правил, нам нужно знать. Начнем с обзора классов для отображения данных на странице, а затем перейдем к классам работы с формами.

При каждом запросе запускается функция вьюшки. А когда имеем дело с классами, тогда при каждом запросе создается объект из класса вьюшки и запускается ее встроенный метод [dispatch](http://djbook.ru/rel1.7/ref/class-based-views/base.html#django.views.generic.base.View.dispatch). Этот метод наследуют от встроенных Django вьюшек. Данный метод запускает одноименный метод под названием типа запроса: get, post, head и т.д. Данные методы объекта класса можем использовать как по-умолчанию с унаследованной базовой вьюшки, так и описывать в своем классе при необходимости.

Таким образом, для каждого аспекта обработки запроса данных и формирования ответа, в Django классах вьюшек предусмотрены свои атрибуты и методы класса. Нужно знать набор наиболее популярных методов и атрибутов, чтобы иметь возможность их кастомизировать на уровне своего класса.

Базовым классом есть [View](http://djbook.ru/rel1.7/ref/class-based-views/base.html#django.views.generic.base.View) и он имеет такие важные для нас методы и атрибуты:

* [as_view](http://djbook.ru/rel1.7/ref/class-based-views/base.html#django.views.generic.base.View.as_view): [статический метод] (https://docs.python.org/2/library/functions.html#staticmethod) (имеет декоратор staticmethod) используется в URL шаблонах, ведь мы не можем напрямую передать класс в url функцию в модуле urls.py ;
* get, post, head и т.д.: для обработки запроса соответствующего типа

Класс [TemplateView](http://djbook.ru/rel1.7/ref/class-based-views/base.html#templateview) дополнительно подготовит и отдаст в ответе шаблон с HTML кодом:

* template_name: атрибут, указывающий на путь к файлу шаблона;
* [get_context_data](http://djbook.ru/rel1.7/ref/class-based-views/mixins-simple.html#django.views.generic.base.ContextMixin.get_context_data): метод возвращает словарь с дополнительными данными для шаблона.

Класс [RedirectView](http://djbook.ru/rel1.7/ref/class-based-views/base.html#redirectview):

* [get_redirect_url](http://djbook.ru/rel1.7/ref/class-based-views/base.html#django.views.generic.base.RedirectView.get_redirect_url): метод, отдает URL адрес для редиректа;
* url: атрибут, в который можно поместить статическую строку-адрес для редиректа.

Класс [DetailView](http://djbook.ru/rel1.7/ref/class-based-views/generic-display.html#detailview) работает для генерации списка объектов из базы данных:

* [model](http://djbook.ru/rel1.7/ref/class-based-views/mixins-multiple-object.html#django.views.generic.list.MultipleObjectMixin.model): атрибут, который указывает на класс модели, с которым будет работать данная вьюшка;
* [get_queryset](http://djbook.ru/rel1.7/ref/class-based-views/mixins-single-object.html#django.views.generic.detail.SingleObjectMixin.get_queryset): метод, который задает кастомный запрос в базу для получения единого объекта заданного типа;
* get_context_data: такой же метод, как и в TemplateView классе;
* get_object: возвращает объект из базы, который будем представлять на странице.
* [render_to_response](http://djbook.ru/rel1.7/ref/class-based-views/mixins-simple.html#django.views.generic.base.TemplateResponseMixin.render_to_response)
* object: переменная доступная в шаблоне для получения объекта, что выводим.

Класс [ListView](http://djbook.ru/rel1.7/ref/class-based-views/generic-display.html#django.views.generic.list.ListView), который используем для отображения списка объектов из базы данных:

* [paginate_by](http://djbook.ru/rel1.7/ref/class-based-views/mixins-multiple-object.html#django.views.generic.list.MultipleObjectMixin.paginate_by): атрибут, указывающий на количество элементов на странице; так, данный класс реализует для нас постраничную навигацию;
* [object_list](http://djbook.ru/rel1.7/ref/class-based-views/mixins-multiple-object.html#django.views.generic.list.MultipleObjectMixin.get_context_data): список объектов под данным названием доступен в шаблоне;
* также данный класс передает в шаблон переменные для работы с постраничной навигацией по списку: is_paginated, paginator, page_obj;
* все другие методы подобные как в классе DetailView: get_context_data, get_queryset.

C> ...

Давайте теперь рассмотрим небольшой, скорее теоретический, пример класса вьюшки и его использования. Сделаем вьюшку список студентов, но на этот раз используя классы. Воспользуемся базовым классом ListView:

{title="Класс вьюшки списка студентов",lang="python"}
~~~~~~~~
from django.views.generic import ListView
from students.models.students import Student

class StudentList(ListView):
    model = Student
~~~~~~~~

Добавим данную вьюшку к URL шаблонам:

{title="Вот как прописываются классовые вьюшки в urls.py",lang="python"}
~~~~~~~~
from django.conf.urls import patterns, url
from students.views.students import StudentList

urlpatterns = patterns('',
    url(r'^student_list/$', StudentList.as_view()),
)
~~~~~~~~

И это весь Python код, который нам нужно писать для списка студентов. Остался шаблон. Сделаем его очень простым:

{title="Шаблон для списка студентов",lang="html"}
~~~~~~~~
{% extends "base.html" %}

{% block content %}
    <h2>Студенты</h2>
    <ul>
        {% for student in object_list %}
            <li>{{ studnet.last_name }}</li>
        {% endfor %}
    </ul>
{% endblock %}
~~~~~~~~

A> Класс вьюшки автоматически ищет шаблон под названием "students/student_list.html", где "students" берется из названия приложения, "student" - из названия модели, "list" - из названия вьюшки "ListView". Или, альтернативно, можем добавить атрибут класса "template_name" к классу StudentList, чтобы использовать шаблон с другим названием.

В шаблоне мы воспользовались переменной "object_list", который нам передала вьюшка. Это список студентов в базе. Мы можем ограничить данный список из get_queryset метод на классе вьюшки, а также можем установить дополнительные данные для шаблона i еще несколько дополнительных кастомизаций:

{title="Больше кастомизаций в классе вьюшки",lang="python"}
~~~~~~~~
from django.views.generic import ListView
from students.models.students import Student

class StudentList(ListView):
    model = Student
    context_object_name = 'students'
    template = 'students/student_class_based_view_template'

    def get_context_data(self, **kwargs):
        """This method adds extra variables to template"""
        # get original context data from parent class
        context = super(StudentList, self).get_context_data(**kwargs)

        # tell template not to show logo on a page
        context['show_logo'] = False

        # return context mapping
        return context

    def get_queryset(self):
        """Order students by last_name."""
        # get original query set
        qs = super(StudentList, self).get_queryset()

        # order by last name
        return qs.order_by('last_name')
~~~~~~~~

В усложненном классе мы:

* изменили название переменной, содержащей список студентов в шаблоне на "students";
* установили кастомное название шаблона через атрибут "template";
* добавили переменную "show_logo" в контекст шаблона;
* изменили порядок студентов, отсортировав их по фамилии.

**Классы для работы с формами**

В завершение теоретической части о вьюшках-классах, рассмотрим еще набор определенных классов по работе с формами.

Базовый класс для всех вьюшек с формами называется [FormView] (http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#django.views.generic.edit.FormView) . Он отображает форму, показывает ошибки валидации и при успешном действии - редиректит на новый URL адрес. Вот основные атрибуты и методы:

* подобные атрибутам и методам, которые мы уже с вами рассмотрели в предыдущих классах: template_name, get, post, put, dispatch, as_view, get_context_data, model;
* fields: атрибут; указывает на список полей, которые отобразить на форме;
* [form_class](http://djbook.ru/rel1.7/ref/class-based-views/mixins-editing.html#django.views.generic.edit.FormMixin.form_class): атрибут, который указывает на класс формы; вместо него можно определять метод [get_form_class](http://djbook.ru/rel1.7/ref/class-based-views/mixins-editing.html#django.views.generic.edit.FormMixin.get_form_class);
* initial: атрибут, словарь с исходными данными для формы;
* success_url: атрибут, адрес страницы для редиректа после успешной обработки формы; вместо него можно использовать метод [get_success_url](http://djbook.ru/rel1.7/ref/class-based-views/mixins-editing.html#django.views.generic.edit.FormMixin.get_success_url);
* form_valid: метод, который редирект на страницу при успешной обработке формы;
* form_invalid: рендерит ответ пользователю, содержащий форму с указанием ошибками.

Класс для формы создания нового объекта [CreateView](http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#createview):

* object: атрибут, указывающий на вновь созданный объект;
* остальные методы и атрибуты, которые были упомянуты в перечне к классу FormView.

Класс для формы редактирования существующего объекта [UpdateView](http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#updateview). Поддерживает все атрибуты и методы определеные в классе CreateView.

Класс для удаления существующего объекта из базы [DeleteView](http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#deleteview). Важнейшие атрибуты - это model и success_url.

Как пользоваться базовой формой и вьюшкой-функцией мы уже знаем из секции о разработке формы контакта администратора. А вот так можно это сделать используя класс. Привожу упрощенный вариант логики:

{title="Контакт форма через класс вьюшки",lang="python"}
~~~~~~~~
from django.views.generic.edit import FormView

class ContactView(FormView):
    template_name = 'contact_form.html'
    form_class = ContactForm
    success_url = '/email-sent/'

    def form_valid(self, form):
        """This method is called for valid data"""
        subject = form.cleaned_data['subject']
        message = form.cleaned_data['message']
        from_email = form.cleaned_data['from_email']

        send_mail(subject, message, from_email, ['admin@gmail.com'])

        return super(ContactView, self).form_valid(form)
~~~~~~~~

A> На домашнее задание: полностью перепишите функцию-вьюшку формы контакта администратора на класс, который будет наследоваться от FormView.

FormView класс для нас определяет набор методов и атрибутов таким образом, что нам не надо писать много условных операторов для проверки на тип запроса и тому подобные вещи.

**Формы работы с моделями**

Классы UpdateView, CreateView и DeleteView являются так называемыми вьюшками для работы с моделями. Каждая из них меняет определенным образом базу данных и оперирует над тем или иным классом модели.

Чтобы указать данным классам, с какими объектами они будут работать используются следующие варианты в порядке их важности:

* если определенный атрибут "model" на уровне класса, тогда он используется;
* если определенный метод "get_object" возвращает объект, тогда класс данного объекта будет использоваться в качестве модели;
* если определенный "queryset", тогда модель определена в нем будет использоваться в дальнейшей работе класса-вьюшки.

C> ...

На этом с теорией завершаем и переходим к практике. Реализуем форму редактирования студента.

Но вам, перед переходом к практике, рекомендую еще почитать [о формах] (http://djbook.ru/rel1.7/topics/class-based-views/index.html) и попробовать самостоятельно разобраться, если информации данной секции не хватило вам для полного понимания.

### Вьюшка-класс для редактирования студента

На этот раз начнем не с подключения шаблонов, а прямо из класса вьюшки. Открываем в своем любимом редакторе кода модуль students.py с пакета views в аппликации students и добавляем следующий класс:

{title="Класс-вьюшка для редактирования студента",lang="python"}
~~~~~~~~
from django.http import HttpResponse, HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.views.generic import UpdateView

from ..models import Student, Group

class StudentUpdateView(UpdateView):
    model = Student
    template_name = 'students/students_edit.html'

    def get_success_url(self):
        return u'%s?status_message=Студент успешно сохранен!' \
            % reverse('home')

    def post(self, request, *args, **kwargs):
        if request.POST.get('cancel_button'):
            return HttpResponseRedirect(
                u'%s?status_message=Редактирование студента отменено!' %
                reverse('home'))
        else:
            return super(StudentUpdateView, self).post(request, *args, **kwargs)
~~~~~~~~

Думаю, большинство вещей понятны основываясь на материале предыдущей секции, но, все же, вкратце пройдемся по важным моментам:

* 3я: все дефолтные вьюшки-классы Django живут в пакете "django.views.generic";
* 7я: наш класс вьюшки наследуется от класса UpdateView, ведь мы реализуем форму редактирования;
* 8я: модель, с которой будет работать наша страница - Student;
* 9я: шаблон для страницы редактирования страница лежит по адресу "students/students_edit.html";
* 11я: метод, который возвращает URL страницу для редиректа после успешного сохранения студента;
* 15я: метод post мы также кастомизировали, чтобы отдельно обрабатывать кнопку "Отмена" на форме; при ее нажатии мы переадресовываем пользователя на страницу со списком студентов;
* 22я: а всю тяжелую работу (валидация данных, сохранение студента, подготовка ошибок при некорректных данных) для нас сделает метод "post" родительского класса.

Вот и все! Трудно поверить, что 23 строки кода (вместе с импортом) - это все, что нужно для редактирования студента? Мне также было трудно в это поверить, когда я впервые познакомился с данными формами.

А теперь скопируем шаблон для редактирования студента из шаблона добавления студента:

{title="Копируем шаблон добавления студента",lang="shell"}
~~~~~~~~
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/templates/students
$ cp students_add.html students_edit.html
~~~~~~~~

Открываем students_edit.html и приводим к следующему виду:

{title="Шаблон для работы с вьюшкой-классом, students_edit.html",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}

{% block meta_title %}Редактировать Студента{% endblock meta_title %}

{% block title %}Редактировать Студента{% endblock title %}

{% block status_message %}
{% if form.errors %}
<div class="alert alert-warning" role="alert">Пожалуйста, исправьте следующие ошибки</div>
{% endif %}
{% endblock %}

{% block content %}

<form action="{% url "students_edit" object.id %}" method="post" enctype="multipart/form-data">
  {% csrf_token %}

  {{ form.as_p }}

  <input type="submit" value="Сохранить" name="add_button"
         class="btn btn-primary" />
  <button type="submit" name="cancel_button" value="Отменить"
          class="btn btn-link">Отменить</button>
</form>


{% endblock content %}
~~~~~~~~

В данном шаблоне мы:

* обновили заголовки страницы;
* кастомизировали блок status_message, чтобы выводить ошибки валидации формы;
* вставили переменную формы "{{ form.as_p }}" подобно тому как сделали это с формой контакта администратора.

Ничего нового в данном шаблоне для нас не появилось. Заметьте, что данный класс вьюшки даже не нуждался в классе формы, а сгенерировал для нас все поля формы просто имея атрибуты "model" установленый в значение Student. Атрибут класса form_class нам пригодится, когда применим Crispy Forms стиле в нашей форме.

Осталась единственное изменение: обновить urls.py шаблон для страницы с формой редактирования:

{title="urls.py",lang="python"}
~~~~~~~~
...
from students.views.students import StudentUpdateView
...
urlpatterns = patterns('',
    ...
    url(r'^students/(?P<pk>\d+)/edit/$',
         StudentUpdateView.as_view(),
         name='students_edit'),
    ...
~~~~~~~~

URL шаблоны умеют работать только с объектами, которые можно вызвать (callable), поэтому передать напрямую класс мы не можем. Но имеем в классах вьюшек статический метод "as_view", который специально предназначен для возвращения функции, что оборачивает наш класс в виде функции для URL шаблона.

Все. Так, несколькими строками кода, даже без декларации класса формы, а только с классом вьюшки, мы получили полноценную форму редактирования студента вместе с валидацией и сохранением данных в базу.

A> На домашку: попробуйте сделать форму редактирования определив отдельно класс формы и вручную прописав все необходимые поля. Так же как мы это делали с формой контакта. Просто для практики и, чтобы запомнить.


### Crispy Forms стили

В завершение данной секции приведем нашу форму редактирования студента к приемлемому виду. Опять же используя Crispy Forms приложение.

Все действия аналогичны тем, которые мы проделывали с формой контакта администратора. Поэтому сделаем это достаточно быстро и без дополнительных дублирующих объяснений.

Если до этого момента мы обходились без класса формы, то теперь должны его создать, чтобы установить объект класса FormHelper атрибутом в форму.

Вот как будет выглядеть класс формы редактирования студента:

{title="Класс формы студента, views/students.py",lang="python"}
~~~~~~~~
# -*- coding: utf-8 -*-
from datetime import datetime

from django.shortcuts import render
from django.http import HttpResponse, HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.forms import ModelForm
from django.views.generic import UpdateView

from crispy_forms.helper import FormHelper
from crispy_forms.layout import Submit
from crispy_forms.bootstrap import FormActions

from ..models import Student, Group


class StudentUpdateForm(ModelForm):
    class Meta:
        model = Student

    def __init__(self, *args, **kwargs):
        super(StudentUpdateForm, self).__init__(*args, **kwargs)

        self.helper = FormHelper(self)

        # set form tag attributes
        self.helper.form_action = reverse('students_edit',
            kwargs={'pk': kwargs['instance'].id})
        self.helper.form_method = 'POST'
        self.helper.form_class = 'form-horizontal'

        # set form field properties
        self.helper.help_text_inline = True
        self.helper.html5_required = True
        self.helper.label_class = 'col-sm-2 control-label'
        self.helper.field_class = 'col-sm-10'

        # add buttons
        self.helper.layout[-1] = FormActions(
            Submit('add_button', u'Сохранить', css_class="btn btn-primary"),
            Submit('cancel_button', u'Отменить', css_class="btn btn-link"),
        )

class StudentUpdateView(UpdateView):
    model = Student
    template_name = 'students/students_edit.html'
    form_class = StudentUpdateForm

    def get_success_url(self):
        return u'%s?status_message=Студент успешно сохранен!' \
            % reverse('home')

    def post(self, request, *args, **kwargs):
        if request.POST.get('cancel_button'):
            return HttpResponseRedirect(
                u'%s?status_message=Редактирования студента отменено!' %
                reverse('home'))
        else:
            return super(StudentUpdateView, self).post(request, *args, **kwargs)
~~~~~~~~

Мы создали класс формы StudentUpdateForm, который наследуется от ModelForm. Благодаря наследованию наша форма получает весь функционал по работе с моделями и базой данных.

Подобным образом как мы это делали с формой контакта администратора, мы определили объект helper и "расширили" его рядом атрибутов для лучшего визуального представления формы. Единственное отличие заключается в том, что здесь мы добавили две кнопки и окутали их в лэйаута FormActions (строка 41). Он придаст специальный тег div который обернет теги кнопок. Позже можно его использовать для кастомных стилей.

Также в классе вьюшки, в строке 51, мы подключили класс формы с помощью атрибута form_class. Все остальное в этом классе осталось без изменений.

Теперь очередь шаблона. Что и как в нем делать после применения Crispy Forms вы уже знаете:

{title="Шаблон формы редактирования студента с Crispy Forms",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}
{% load crispy_forms_tags %}

{% block meta_title %}Редактировать Студента{% endblock meta_title %}

{% block title %}Редактировать Студента{% endblock title %}

{% block status_message %}
{% if form.errors %}
<div class="alert alert-warning" role="alert">Пожалуйста, исправьте следующие ошибки</div>
{% endif %}
{% endblock %}

{% block content %}

{% crispy form %}

{% endblock content %}
~~~~~~~~

Мы загрузили теги с Crispy Forms приложения и заменили тег формы тегом "{% crispy form %}". Это все.

Опять обновите страницу с формой редактирования студента и убедитесь, что ваш результат является похожим на следующее изображение:

![Форма редактирования студента готова!](images/edit_student_form_ready.jpg)


A> На домашнее задание: перевести форму добавления студента также на форму моделей Django и пользоваться единым шаблоном как для добавления, так и для редактирования студента.

A> Еще одно упражнение: попытаться переписать форму редактирования студента без использования Django форм - полностью вручную. Так же, как мы это делали с формой добавления студента. С целью практики. Даст вам хорошее понимание работы с данными из базы и данными от пользователя. Здесь будет несколько нюансов, которых не было с формой добавления. Плюс логика по сохранении объекта в базу, конечно, будет немного другой.

Как видите, использование Django форм для работы с моделями позволило нам несколькими строками Python кода реализовать довольно сложную форму. В следующих главах книги мы еще будем иметь дело с Django формами.

## Удаление студента

Добавлять и редактировать существующего студента мы уже научились, и думаю, сможем делать подобные вещи довольно просто и быстро. На повестке дня - разобраться с удалениями существующих объектов из базы данных.

Для этого снова воспользуемся максимально быстрым способом: Django классами вьюшек для работы с моделями - [DeleteView](http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#deleteview).

Наш собственный класс будет наследоваться от DeleteView и декларировать два атрибута и один метод:

* model: класс модели, c которым будем работать;
* template_name: путь к шаблону, содержащий подтверждающее сообщение об удалении студента;
* get_success_url: метод, что возвращает путь редиректа после успешного удаления студента.

Вот необходимые обновления к нашему модуля с вьюшкой students.py:

{title="Класс-вьюшка для удаления студента",lang="python"}
~~~~~~~~
class StudentDeleteView(DeleteView):
    model = Student
    template_name = 'students/students_confirm_delete.html'

    def get_success_url(self):
        return u'%s?status_message=Студент успешно удален!' \
            % reverse('home')
~~~~~~~~

Как видите, нам снова не пришлось писать никакой логики по валидации формы или удалении объекта из базы данных.

Теперь скопируем один из существующих конечных шаблонов в "students_confirm_delete.html". Этот шаблон будет отображать сообщение о подтверждении удаления студента. Важно не сразу удалять студента при клике на Действие Удалить, а еще раз переспросить пользователя об окончательном удаления. Ведь это действие окончательное:

{title="Создаем шаблон students_confirm_delete.html",lang="shell"}
~~~~~~~~
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/templates/students
$ cp students_edit.html students_confirm_delete.html
~~~~~~~~

Открываем новый шаблон и обновляем следующим кодом:

{title="Конечный вид шаблона students_confirm_delete.html",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}

{% block meta_title %}Удалить Студента{% endblock meta_title %}

{% block title %}Удалить Студента{% endblock title %}

{% block content %}

<form action="{% url "students_delete" object.id %}" method="post">
  {% csrf_token %}
  <p>Вы действительно хотите удалить студента "{{ object }}"?</p>
  <input type="submit" value="Да" name="delete_button"
         class="btn btn-danger" /><br /><br />
</form>

{% endblock content %}
~~~~~~~~

Как видите код довольно прост. Мы добавили форму, которая отсылает данные на себя ('{% url "students_delete" object.id%}') и содержит вопрос, действительно ли пользователь хочет удалить студента. Также добавили кнопку "Да" для подтверждения действия.

Обратите внимание, что вьюшка DeleteView также передает текущий объект студента в переменную "object" в шаблоне. Еще одна интересная вещь: когда вставляем напрямую объект в шаблон ("{{object}}"), тогда используется его метод "\_\_unicode\_\_" для генерации строки-представления объекта на нашей странице.

Осталась последнее дело: обновить URL шаблон для нашей страницы подтверждения удаления студента:

{title="DeleteView в urls.py",lang="python"}
~~~~~~~~
from students.views.students import StudentUpdateView, StudentDeleteView

...
    url(r'^students/(?P<pk>\d+)/delete/$',
         StudentDeleteView.as_view(),
         name='students_delete'),
...
~~~~~~~~

Что мы изменили в данном модуле:

* добавили импорт StudentDeleteView;
* изменили название группы с "sid" студента на "pk";
* изменили ссылки на вьюшку:"StudentDeleteView.as_view()".

Готово! В списке действий студента выбирайте "Удалить" и удалите одного из студентов. Убедитесь, что вид и функционал формы работает корректно.

![Удаление студента](images/student_delete.jpg)

A> На домашнее задание: реализовать аналогичным образом удаление групп.

A> Еще одна задача: реализовать удаление студента полностью вручную без Django форм.

A> Ну и для совсем "продвинутых". Реализовать возможность удаления сразу нескольких студентов. Для этого нужно будет добавить чекбоксы в список со студентами, а также кнопки Удалить внизу или сверху данного списка.

Очередной раз убеждаемся насколько быстро и легко создавать стандартный функционал по работе с базой данных, если под руками Django формы. Конечно, сначала надо провести некоторое время практикуясь с ними, но позже это окупается с вторицею.

## Кастомизация административной части Django

В завершение данной главы посмотрим, каким образом можно изменять админ интерфейс Django. Сначала разберем теоретические основы и возможности для кастомизации, а потом сделаем 2 практические задачи:

* улучшим список студентов в админке функциями поиска, фильтра и редактированием;
* реализуем валидацию модели студента, чтобы нельзя было назначить студента в группу, если он староста в другой группе; то есть группа должна совпадать с той, где данный студент является старостой.


### Теория админки

Django предоставляет [широкие возможности] (http://djbook.ru/rel1.7/ref/contrib/admin/index.html) для кастомизации административной части.

Все изменения происходят через Python класс, который должен наследоваться от ModelAdmin.

Вот список наиболее часто используемых атрибутов и методов данного класса для кастомизации админ части той или иной модели:

* actions: список дополнительных действий над элементами в списке моделей; обычно эти actions разработчик сам реализует;
* actions_selection_counter: показывать или нет счетчик выбранных среди списка объектов;
* exclude: список полей, которые исключить из формы редактирования модели;
* fields: список полей, которые включить в форму редактирования модели;
* form: назначение кастомного класса формы; используется для серьезных изменений в функционале и виде формы редактирования модели; позже мы воспользуемся данным атрибутом;
* list_display: список полей модели для отображения в списке;
* list_display_links: какие из полей модели в списке будут обернуты в ссылку, которая будет указывать на форму редактирования объекта
* list_editable: список полей, которые можно будет отредактировать прямо в списке объектов; не заходя на форму редактирования;
* list_filter: список полей для генерации фильтров;
* list_per_page: количество объектов на одной странице;
* ordering: список полей, по которым изначально сортировать объекты;
* readonly_fields: список полей, которые нельзя будет редактировать на форме;
* search_fields: список полей, по которым можно будет производить поиск объектов;
* view_on_site: метод, возвращающий URL адрес к фронт-энд вьюшке объекта.

Еще есть много других атрибутов и методов, которые, позволяют полностью переписать формы и шаблоны админки ваших моделей. Но их рассматриватьздесь не будем.

Таким образом, достаточно определить свой класс и прописать необходимые методы и атрибуты внутри, чтобы влиять на вид и функционал административной части выбранной модели. А начнем с улучшения функций для списка студентов

### Улучшаем список студентов в админке

Вот как выглядит список студентов на данный момент. Сравним его в конце данной секции, когда сделаем все улучшения:

![Дефолтная админка списка студентов](images/students_list_admin.jpg)

Мы уже заранее зарегистрировали класс модели студента для Django админки, и теперь остается только определить отдельный класс для админ вьюшки и подвязать ее к модели студента. Пока она будет у нас пустая:

{title="Админ вьюшка, модуль admin.py в корне приложения students",lang="python"}
~~~~~~~~
# -*- coding: utf-8 -*-
from django.contrib import admin

from .models import Student, Group

class StudentAdmin(admin.ModelAdmin):
    pass

admin.site.register(Student, StudentAdmin)
admin.site.register(Group)
~~~~~~~~

Мы создали класс StudentAdmin и наследовали его от ModelAdmin, ведь все вьюшки в админке - это вьюшки для работы с моделями. Кроме того, мы передали данный класс вторым аргументом в функцию "register". Теперь модель студента связана с только что созданным классом вьюшки.

Мы готовы к тому, чтобы наполнить наш класс полезными вещами:

{title="Улучшаем вид списка студентов",lang="python"}
~~~~~~~~
from django.core.urlresolvers import reverse

class StudentAdmin(admin.ModelAdmin):
    list_display = ['last_name', 'first_name', 'ticket', 'student_group']
    list_display_links = ['last_name', 'first_name']
    list_editable = ['student_group']
    ordering = ['last_name']
    list_filter = ['student_group']
    list_per_page = 10
    search_fields = ['last_name', 'first_name', 'middle_name', 'ticket',
        'notes']

    def view_on_site(self, obj):
        return reverse('students_edit', kwargs={'pk': obj.id})
~~~~~~~~

Теперь давайте построчно еще раз пройдемся по атрибутах и методах класса:

* 4я: отражаем в заданном порядке Фамилия, Имя, Билет и Группу студента в списке;
* 6я: поля Имя и Фамилия будут в виде ссылок на форму редактирования студента;
* 7я: поле Группа можно теперь будет редактировать прямую на списке студентов; это ускорит действия администратора по распределению студентов по группам;
* 8я: по-умолчанию список студентов будет рассортированных по фамилии;
* 9я: в правой колонке у списка студентов появится возможность фильтровать студентов по группам; это удобно для работы со студентами в контексте той или иной группы;
* 10я: указываем постраничной навигации отражать 10 студентов на одной странице;
* 11я: добавляем форму поиска студентов, которая будет искать среди всех текстовых полей в модели студента: Фамилия, Имя, Отчество, Билет и дополнительные заметки;
* 15я: добавляем кнопку "Посмотреть на сайте" к форме редактирования студента; таким образом администратор сможет одним кликом попасть на фронт-энд представления текущего студента; в нашем случае это форма редактирования студента; данный метод "view_on_site" возвращает URL адрес страницы.

Все довольно просто и согласно тех определений, которые мы просмотрели в предыдущей секции с теоретическим вступлением.

После всех вышеперечисленные изменений вот как будет выглядеть наш список студентов:

![Улучшенный список студентов](images/students_list_admin_improved.jpg)

Форма поиска, фильтры, сортировка, поля, редактирование, постраничная навигация - все это и еще кое-что, мы смогли сделать несколькими строками кода в классе вьюшки управления видом студентов в административной части Django.

A> На домашнее задание: улучшите список групп в административной части Django подобным образом до того, как мы это сделали со списком студентов. Добавьте функции поиска и фильтра, чтобы работать с группами было значительно удобнее.

Сложная задача: разобраться с [действиями] (http://djbook.ru/rel1.7/ref/contrib/admin/actions.html) в Django админке и реализовать функцию копирования выбранных студентов в списке.

Теперь перейдем к несколько более сложной задачи.

### Валидатор для поля Группы

Каждый из студентов должен быть назначен в ту или иную группу. В то же время, некоторые из студентов могут быть выбраны в качестве старост для групп.

На данный момент на форме редактирования студента в административной части мы можем выбирать любую существующую группу в поле Группа. На самом деле в реальной жизни не бывает так, чтобы студент учился в одной группе, а был старостой другой группы. Однако, используя наши админ формы, мы можем такое сделать. Нужно исправить данный функционал и обезопасить администратора сайта от подобных ошибок по настройке студентов и групп.

Быть в курсе всех студентов, групп и старост является непосильной задачей для человека, поэтому решение данной проблемы должно лежать на уровне кода, а не на уровне знания пользователя нашего приложения.

Это все можно исправить с помощью дополнительной валидации поля Группа на форме редактирования студента. При каждой попытке обновить студента мы будем проверять выбрана группа совпадает с группой, в которой данный студента является старостой. Конечно, если данный студент не является старостой в одной группе, тогда и проверять ничего не нужно. Любая группа для него будет разрешенной.

Со спецификациями данной задачи разобрались, поэтому переходим непосредственно к реализации.

Чтобы добавить валидатор нужно иметь класс формы. На данный момент мы его еще не создали. Поэтому добавляем форму и пропишем ее в атрибут form_class нашей вьюшки, чтобы связать их друг с другом. Привожу сразу конечный код метода валидации, а затем разберемся в деталях:

{title="Валидация поля student_group",lang="python"}
~~~~~~~~
# -*- coding: utf-8 -*-
from django.contrib import admin
from django.core.urlresolvers import reverse
from django.forms import ModelForm, ValidationError

from .models import Student, Group


class StudentFormAdmin(ModelForm):

    def clean_student_group(self):
        """Check if student is leader in any group.

        If yes, then ensure it's the same as selected group."""
        # get group where current student is a leader
        groups = Group.objects.filter(leader=self.instance)
        if len(groups) > 0 and \
            self.cleaned_data['student_group'] != groups[0]:
            raise ValidationError(u'Студент является старостой другой группы.',
                code='invalid')

        return self.cleaned_data['student_group']

class StudentAdmin(admin.ModelAdmin):
    list_display = ['last_name', 'first_name', 'ticket', 'student_group']
    list_display_links = ['last_name', 'first_name']
    list_editable = ['student_group']
    ordering = ['last_name']
    list_filter = ['student_group']
    list_per_page = 10
    search_fields = ['last_name', 'first_name', 'middle_name', 'ticket',
        'notes']
    form = StudentFormAdmin

    def view_on_site(self, obj):
        return reverse('students_edit', kwargs={'pk': obj.id})

admin.site.register(Student, StudentAdmin)
admin.site.register(Group)
~~~~~~~~

Давайте построчно пройдемся по последним обновлениям:

* 9я: создаем класс StudentFormAdmin, который наследуется от ModelForm;
* 11я: в Django формах перед вызовом методов is_valid и is_invalid вызываются методы валидации и преобразования данных с названиями clean_ [название поля]; мы воспользовались данным подходом и перекрыли метод валидация именно поля группы "clean_student_group"; он не принимает никаких атрибутов, но текущий объект формы имеет атрибут cleaned_data, которым мы и воспользуемся, чтобы узнать какую именно группу выбрал пользователь на форме редактирования студента;
* 16я: вытаскиваем все группы из базы данных, в которых данный студент есть старостой;
* 17я: если данный студент является старостой хотя бы в одной группе, а также эта группа не совпадает с группой, которая была только что избранная на форме редактирования ...;
* 19я: тогда выбрасываем специальную ошибку ValidationError, которой передаем сообщение для отображения пользователю;
* 23я: в случае, если валидация проходит успешно, мы просто возвращаем значения выбранного поля student_group по методу;
* 36я: привязываем наш класс формы к админ вьюшки.

Теперь, чтобы потестировать наш валидатор, нужно соответственно настроить группу и студента. В одной из групп добавьте студента в качестве старосты. Затем на форме редактирования данного студента попробуйте выбрать другую группу и сохранить. При этом вы должны получить сообщение над полем: "Студент является старостой другой группы.".

A> Как понимаете, валидация только со стороны формы редактирования студента будет неполной, ведь еще остается возможность на форме группы выбирать старосту. Поэтому даю вам на самостоятельную проработку реализацию валидатора поля Староста Группы. Данный валидатор не позволит выбрать студента, если он не относится к текущей группы (то есть его поле student_group не указывает на эту группу).

A> Еще одна задача. Добавьте аналогичную валидацию к нашим собственным фронте-энд формам редактирования студента и группы.

A> Не забываем о репозиторий кода и регулярных комитах отдельных задач, а также помним о хороших пояснительных комментариях.


## Домашнее задание

В течение данной главы мы освоили массу нового материала. Давайте подытожим:

* работа с HTML формами;
* обработка форм, валидация, работа с ошибками;
* использование Django форм и форм работы с моделями;
* реализация форм добавления, удаления и редактирования объектов в базе;
* создание правильным статусных сообщений и ответов после действий над формами;
* использование Twitter Bootstrap стилей с помощью Crispy Forms аппликации;
* кастомизация Django административного интерфейса.

В каждой из секций вы встречали далеко не одно домашнее задание. Как вы понимаете, они там не только для прочтения, но и для самостоятельной реализации. Поэтому выделите себе несколько дней, а может недель и хотя бы попробуйте каждое из них.

А для тех, кому все дается слишком легко, вот еще несколько идей и напоминаний:

* реализовать все (редактирование, добавление и удаление) формы работы со Студентами, Группами и Экзаменами;
* реализовать данные формы двумя способами: полностью вручную и с помощью Django форм работы с моделями.

* Я специально даю вам такую рутинную работу. Ведь с количеством придет качество и полное понимание концепций. Обычно, если я что-то не понимаю, я его заучиваю, и после этого понимания непременно приходит.*

Поэтому не ленитесь и результаты уже будут не за горами.

Также в коде который идет с книгой можете найти код форм менеджмента группами. Там есть несколько новых фишек, которые мы не рассмотрели в данной главе.

C> ...

Таким образом, данной главой мы заканчиваем самый базовый материал книги. Формы, модели и вьюшки - это необходимый минимум основных знаний, без которых невозможно найти работу и вообще двигаться дальше. Да, он не является достаточным, но без него никуда. Поэтому выделите достаточно времени на эти три главы.

В следующей главе мы перейдем к динамическим страницам, реализуем закладки Посещение, ознакомимся с языком Javascript и технологией AJAX, сделаем выпадающее меню групп рабочим.
