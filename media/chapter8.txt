# 8. Форми роботи із студентом та групою: Django форми, валідація

Ось і дійшли ми з вами до глави, в якій розберемось із формами.

**Веб-форми** - це інструмент, з допомогою якого користувач може відправити дані на сервер, а не лише використовувати свій браузер у режимі отримування даних. Форми - це дуже показовий елемент веб-розробки, що свідчить про рівень програміста. З однієї сторони це доволі рутинна і трудоємка робота, а з іншої сторони, створити по-справжньому зручні і прості в користуванні форми, є далеко непростою задачею.

Тому дана глава містить доволі важливий і складний матеріал. А саме:

* верстка HTML форми;
* обробка форми на сервері, валідація даних;
* використання вбудованих класів Django форм, форм моделей;
* форми з Twitter Bootstrap та аплікацією Django Crispy Forms;
* кастомізація Django адмінки.

В процесі даної глави ми з вами:

* реалізуємо форму додавання студента практично з нуля;
* побудуємо форму редагування студента використовуючи Django форми моделей;
* реалізуємо функцію видалення існуючих студентів;
* створимо форму контактування адміністратора на закладці Контакт;
* покращимо список студентів в адміністративній частині та допишемо валідатори для поля "Група" на формі редагування студента.

Наприкінці у вас буде повний арсенал роботи із веб-формами як на клієнтській стороні, так і на стороні сервера.

А почнемо ми із невеликої кількості теорії, а саме - HTML форми.

## HTML Форми

Ми вже з вами зовсім коротко захопили теги форм і полів у главі із статичною версткою веб-сторінки. Тут же ж трохи детальніше глянемо на необхідний мінімум для ефективної побудови правильних форм на сайті.

### Огляд

Для користувача форма повинна бути легка, зручна та швидка у використанні. Будь-яка дія користувача, в ідеалі, повинна мати миттєвий фідбек зі сторони нашого коду. Якщо дані введені коректно, тоді після відправки даних на сервер, користувач повинен бачити повідомлення, що його запит успішно оброблений, а поля форми обнулені (знову порожні). Якщо ж дані були введені некоректно, тоді форма зберігає попередньо введені користувачем дані в полях, а також відображає додаткові повідомлення конкретизуючи помилки користувача для подальшого виправлення.

Також, якщо форма була відправлена і оброблена коректно, варто редіректити користувача на іншу сторінку, де повідомляти його про успішність операції.

На серверній частині є дуже важливим не просто отримувати та зберігати дані від користувача, а кожного разу перевіряти ввід даних на коректність. Інакше можемо опинитись із некоректими даними в базі, або, що ще гірше, поламаною базою даних та "хакнутими" веб-сторінками.

Поля форми та вигляд самої форми варто оформляти у зручному для користувача вигляді, додаючи необхідну кількість пояснень, щоб вберегти його від неправильно введених даних.

Для підвищення ефективності роботи із формою, в наш час, велику частину полів динамізують та покращують з допомогою багатого Javascript функціоналу. Наприклад, щоб вводити дані щодо дати і часу, використовується віджет календаря. Для вибору кольору, використовуються так звані "Color Picker".

### HTML код форми

Головний тег при роботі із формами є, звісно, "form". Це невидимий на сторінці тег, який вказує на властивості форми, а також містить поля та кнопки цієї форми.

Найважливішими атрибутами тегу форми є:

* action: вказує адресу, на яку відправляти дані форми;
* [enctype](http://htmlbook.ru/html/form/enctype): тип кодування даних форми перед відправкою на сервер (може бути одним із трьох: "text/plain", "multipart/form-data" та "application/x-www-form-urlencoded"; просто запам'ятайте, що потрібно використовувати значення "multipart/form-data", якщо маєте поля файлів на формі);
* method: метод запиту форми (може бути GET або POST); більше про цей атрибут у наступних секціях;
* name: назва форми; форм на сторінці може бути багато і в такому випадку кожній із них варто надавати інше ім'я; з допомогою імені можна на сервері визначати, яка саме форма була відправлена (особливо, якщо форми мають однаковий "action" атрибут);
* [target](http://htmlbook.ru/html/form/target): вказує, де саме показувати результат відправки форми.

Ось приклад порожньої форми із визначеними необхідними атрибутами:

{title="Тег form",lang="html"}
~~~~~~~~
<form action="/submit_form.html" method="post"
      enctype="multipart/form-data" name="myform">
</form>
~~~~~~~~

Поки дана форма без полів і кнопок. Всередину тегу form можемо додавати один або більше наступних тегів:

* [input](http://htmlbook.ru/html/input): найпоширеніший тег всередині форм; може мати кілька різних типів взалежності від атрибуту ["type"](http://htmlbook.ru/html/input/type) (checkbox, radio, text, hidden, submit і ще багато інших);
* [textarea](http://htmlbook.ru/html/textarea): дозволяє вводити користувачу не лише стрічку тексту, а цілі параграфи тексту;
* [select](http://htmlbook.ru/html/select): набір опцій для вибору доступних у так званій "випадайці" (випадаюче меню); працює у двох режимах дозволяючи вводити як лише одне значення, так і кілька значень одночасно (атрибут "multiple"); опції для вибору формуються з допомогою вкладених тегів ["option"](http://htmlbook.ru/html/option);
* [button](http://htmlbook.ru/html/button) або input[type=submit]: кнопки на формі; в основному використовуються для відправки форми на сервер;
* [label](http://htmlbook.ru/html/label): підписує поле пояснювальним текстом; за допомогою атрибуту "for" можна фокусувати поле при кліку по тегу "label".

Знаючи та розуміючи, коли саме використовувати вищеперечислені теги і їхні атрибути, ви без проблем зможете реалізувати 90% необхідних у вашому проекті форм.


A> button vs input[type=submit]: є два теги, з допомогою яких можна реалізувати кнопки форми. Обидва є рівноцінними по функціоналу. Але button дає кращі візуальні можливості. Зокрема, в тег button можна вкладати внутрішній контент. Тому, в принципі, не надто важливо яким саме тегом ви будете користуватись.

А тепер, давайте зверстаємо просту форму, де скористаємось кількома із вищезгаданих тегів:

{title="Демо HTML форма",lang="html"}
~~~~~~~~
<form action="/submit_form.html" method="post"
      enctype="multipart/form-data" name="myform">

  <input type="hidden" value="27" name="student_id" />

  <div>
    <label for="first_name">Ваше ім'я</label>
    <input type="text" value="" name="first_name"
           id="first_name" />
  </div>

  <div>
    <label for="graduated">Закінчили навчання?</label>
    <input type="checkbox" checked="1" name="graduated"
           value="1" id="graduated" />
  </div>

  <div>
    <label for="gender">Ваша стать</label>
    <input type="radio" name="gender" value="male" 
           id="gender" />
    <input type="radio" name="gender" value="female" />
  </div>

  <div>
    <label for="age">Ваш вік</label>
    <select name="age" id="age">
      <option value="">
        Будь-ласка, виберіть ваш вік
      </option>
      <option value="10">Більше ніж 10</option>
      <option value="20">Більше ніж 20</option>
    </select>
  </div>

  <input type="submit" name="save_button"
         value="Зберегти" />

</form>
~~~~~~~~

A> Якщо замість кирилиці в браузері отримали "абру-кадабру", тоді додайте шапку документа (тег head) і тег із кодуванням UTF-8: '\<meta charset="UTF-8"/\>'. Після цього потрібно перезавантажити сторінку.

Як бачите, тег форми може містити і інші теги. Ми огорнули кожне поле в тег "div", щоб логічно погрупувати поле вводу та відповідну мітку (тег "label"). Крім того, даний тег гарно поскладав кожне поле на окрему стрічку.

Зверніть особливу увагу на те, як працюють поля "checkbox", "radio" i "select".

Ось як виглядатиме дана форма в браузері:

![Демо форма](images/html_form_demo.jpg)

A> На домашнє завдання: розширте дану форму більшою кількістю полів так, щоб усі вищеперечислені теги форми були задіяні.

Цього нам буде достатньо, щоб рухатись далі до практики. Але перед практикою розглянемо ще кілька цікавих моментів.

### GET vs POST

Веб-форми можуть робити запити на сервер двох типів: GET i POST.

Як ми уже пам'ятаємо із попередніх глав, коли ми навігуємо в інтернеті, відкриваючи сторінки з допомогою URL адреси браузера, а також клікаючи по лінках, ми автоматично робимо запити на сервер типу GET. Цей тип запиту отримує дані із сервера.

Для відправки даних на сервер у формі частіше використовується метод POST. Він дозволяє відправити більшу кількість даних, в той час як метод GET має дуже обмежений об'єм даних для відправки на сервер.

Якщо вам потрібно зробити форму, яка змінює дані на сервері, тоді використовуйте метод запиту POST. Якщо ж лише отримати дані із сервера і при цьому об'єм даних відправляється невеликий, тоді метод GET.

Також метод POST кращий тоді, коли форма містить поля, які не варто відображати в URL адресі браузера. Наприклад пароль. З іншої сторони, якщо адреса запиту із усіма полями потрібна для подальшого запам'ятовування користувачу (наприклад в закладці), тоді варто скористатись методом GET. Це буває корисно для форм пошуку та фільтрів даних, щоб пізніше користувач міг легко потрапити на попередньо відконфігуровану сторінку із результатами пошуку.

Таким чином POST буде підходящим для форм додавання, редагування та видалення студента. В той час, як GET краще підійде для форми пошуку на сайті.

### Валідація

Якщо занадто довіряти усім даних, що приходять до нас від користувача, то можемо закінчити повністю поламаними базою даних та веб-сайтом загалом.

Щоб уникати подібних ситуацій, зазвичай, дані форм перевіряються на коректність. В ідеалі дану перевірку роблять у двох місцях: на стороні браузера та на стороні клієнта.

Якщо перевірка на веб-сторінці є необов'язковою, і швидше служить для зручності користувача та швидкості роботи із формою, то серверна валідація даних - це просто необхідність.

Найбільш поширеними прикладами валідації форм є:

* перевірка на введення даних у обов'язкові поля форми;
* перевірка на правильний формат телефонів, емейлів, дат;
* перевірка на достатньо складний та правильний ввід пароля;
* правильний тип файлу та обмеження на розмір файлу.

Наше завдання, як розробників, на сервері, перед виконанням будь-яких операцій над даними із форми, перевірити їхню коректність. І лише, якщо усі дані користувача задовільняють необхідним умовам, продовжувати обробку даних.

Якщо дані введені некоректно, подальша робота із ними припиняється і форма відправляється користувачу повторно. Поля форми зберігають попередньо введені користувачем дані. Також оновлена форма повинна вивести деталі помилок.

### Безпека

На завершення теоретичного вступу в HTML форми розглянемо питання безпеки при роботі із формами.

Необхідний мінімум речей, які нам потрібно застосовувати до наших форм, щоб уникати більшості атак зловмисників, це:

* кодування даних форм при відправці на сервер з допомогою SSL сертифікатів та протоколу [HTTPS](http://uk.wikipedia.org/wiki/HTTPS);
* захист від підробки запиту від імені користувача; так званий [CSRF](http://bit.ly/vpcsrq) (Cross Site Request Forgery атака).

**HTTPS**

Більшість форм логування та реєстрації (та й усі форми, що передають із веб-сторінки на сервер паролі користувача) в інтернеті працюють не через протокол HTTP, а через HTTPS.

![HTTPS протокол для форм із паролем](images/https_login.jpg)

До сторінок, що обслуговуються через протокол HTTPS застосовують SSL сертифікат, з допомогою якого запит на сервер і відповіді від нього шифруються. Тому, навіть, якщо хтось перехопить дані, вони будуть зашифровані. Крім того HTTPS протокол для нас перевіряє чи ми дійсно спілкуємось із коректним сервером, а не підробкою.

*Таким чином, варто дотримуватись простого правила: якщо ви маєте справу із формою, яка відправляє важливі секретні дані, сторінка, на якій дана форма знаходиться, повинна обслуговуватись через HTTPS протокол.*

**CSRF**

Другим базовим захистом форм є захист проти підробок запитів. Уявіть, що обробник вашої форми запустили не із сторінки форми, а із коду, або з посилання на форумі. А клікнув дане посилання ваш користувач, не знаючи про те, що дане посилання піде на обробник даної форми. В браузері можуть на той час залишатись дані залогованої сесії користувача (наприклад дані cookies) і запит пройде успішно від імені даного залогованого на вашому сайті користувача. Це може призвести до неочікуваних і невідворотніх змін на вашому веб-сайті.

Більше про CSRF можете почитати [тут](http://bit.ly/vpcsrq).

Дана проблема вирішується доволі просто. У себе на форму вставляєте приховане поле із певним автоматично згенерованим кодом, а в обробнику форми перевіряєте, чи отримали правильний код із даної форми. Django уже дає нам можливість генерації такого коду, а також саму валідацію для кожної нашої форми.

Ми повернемось до CSRF проблеми, коли розроблятимемо нашу першу форму - форму додавання студента.

C> ...

На цьому закінчуємо із теорією і переходимо до практики:

## Форма додавання студента

Почнемо із реалізації форми додавання студента.

Дану форму розробимо найдовшим можливим шляхом: пишучи HTML код форми самостійно з нуля, а також логіку на сервері (включно з валідацією) власними силами.

В наступній секції ми створимо форму редагування студента. І там ми скористаємось Django формами, які для нас зроблять усю важку частину і по генерації HTML коду, і по валідації, і по збереженні змін в базу даних.

Проте, перед тим, як використовувати базуку, нам спочатку потрібно розібратись як стріляти із пістолета. Тому, перед використанням усього готовенького, спочатку навчимось самостійно писати форму та її обробник. Це допоможе нам далі зрозуміти, що ж закладено у класи Django форм.


### Підключаємо шаблон

В попередніх главах ми уже підключили в'юшку і URL шаблон для форми редагування студента. Але тоді ми зробили так, щоб ця в'юшка повертала статичний текст. Тому давайте переключимо її на використання шаблону.

Для цього спочатку створимо шаблон, скопіювавши його із students_list.html:

{title="Підготовка шаблону students_add.html",lang="shell"}
~~~~~~~~
# заходимо в аплікацію, папку із шаблонами
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/templates/students

# копіюємо students_list.html шаблон
$ cp students_list.html students_add.html
~~~~~~~~

Тепер підключимо новий шаблон до в'юшки з додавання студента:

{title="Підключаємо шаблон, модуль views.py",lang="python"}
~~~~~~~~
def students_add(request):
    return render(request, 'students/students_add.html',
        {})
~~~~~~~~

Думаю, код вище не потребує пояснень. Подібну річ ми уже робили у функції в'юшки списку студентів.

### HTML Форма

Настав час зайнятись самим шаблоном і створити форму додавання студента.

Відкриваємо шаблон students_add.html в редакторі, оновлюємо заголовки та видаляємо увесь вміст блоку "content".

{title="Початкові приготування сторінки редагування студента",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}

{% block meta_title %}Додати Студента{% endblock meta_title %}

{% block title %}Додати Студента{% endblock title %}

{% block content %}

Скоро тут буде форма додавання студента

{% endblock content %}
~~~~~~~~

Приблизно ось так виглядатиме наша заготовка в браузері, коли клацнемо на кнопку Додати Студента:

![Заготовка сторінки Додати Студента](images/student_add_boilerplate.jpg)

Дійшли до головного - до самої форми. Додаємо тег "form", а всередині для кожного поля моделі студента додаємо відповідне поле вводу для користувача:

{title="Базова форма додавання студента",lang="html"}
~~~~~~~~
<form action="{% url "students_add" %}" method="post"
      enctype="multipart/form-data">

  <div>
    <label for="first_name">Ім'я</label>
    <input type="text" value=""
           name="first_name" id="first_name" />
  </div>
  <div>
    <label for="last_name">Прізвище</label>
    <input type="text" value=""
           name="last_name" id="last_name"
           placeholder="Введіть ваше прізвище" />
  </div>
  <div>
    <label for="middle_name">По-батькові</label>
    <input type="text" value=""
           name="middle_name" id="middle_name" />
  </div>
  <div>
    <label for="birthday">Дата Народження</label>
    <input type="text" value=""
           name="birthday" id="birthday"
           placeholder="Напр. 1984-12-30" />
  </div>
  <div>
    <label for="photo">Фото</label>
    <input type="file" value="" name="photo" id="photo" />
  </div>
  <div>
    <label for="ticket">Білет</label>
    <input type="text" value=""
           name="ticket" id="ticket" />
  </div>
  <div>
    <label for="student_group">Група</label>
    <select name="student_group" id="student_group">
      <option value="">Виберіть групу</option>
      <option value="1">МтМ-1</option>
      <option value="2">МтМ-2</option>
    </select>
  </div>
  <div>
    <label for="notes">Додаткові Нотатки</label>
    <textarea name="notes" id="notes" class="form-control"></textarea>
  </div>
  <div>
    <input type="submit" value="Додати" name="add_button" />
    <button type="submit" name="cancel_button">Скасувати</button>
  </div>
</form>
~~~~~~~~

Пройдемось по усіх фажливих моментах даної форми:

* 1ий рядок: form - тег форми; його атрибут action вказує на цю ж саму сторінку, на якій знаходиться наша форма додавання студента; тобто генератор форми і обробник форми у нас буде той самий - функція в'юшки додавання студента; взалежності від типу запиту (GET чи POST) наша в'юшка робитиме дві різні речі; метод запиту є POST, адже ми змінюватимемо дані на сервері з допомогою даної форми; тип кодування даних перед відправкою на сервер: "multipart/form-data", адже нам потрібно буде відправляти файл зображення студента;
* 4ий: div - кожне поле складається, як мінімум, із двох тегів: мітки поля (label) та самого поля вводу; кожну таку пару ми огортаємо в блоковий елемент div, щоб візуально відокремити поля і поставити їх в окремі рядки;
* 5ий: label - для кожного поля вводу додаємо цей тег; він додає пояснення про призначення поля, а також, з допомогою атрибуту "for", прив'язує фокус поля до кліка по мітці; "for" атрибут містить "id" поля, якому відповідає тег "label";
* 6ий: input - поле текстрової стрічки для поля Ім'я студента; значення поля (value) порожнє;
* 13ий: placeholder - цей атрибут вставляє в поле текст, який ми зазвичай використовуємо для пояснення користувачу, що саме потрібно ввести у дане поле; як тільки користувач починає вводити текст у дане поле, placeholder стрічка одразу зникає; на домашнє завдання: додайте атрибут "placeholder" до усіх полів форми;
* 28ий: input[type=file] - поле типу "file" призначене для відправки файлів на сервер;
* 37ий: select - даний тег використовуємо для відображення списку існуючих груп в аплікації;
* 38ий: option - з допомогою даного тегу набиваємо список груп; в даний момент він у нас статичний, пізніше ми його динамізуємо існуючими групами з бази;
* 45ий: textarea - тег для вводу багатострічкового тексту; замість атрибуту "value", значення даного поля вводиться всередині тегу;
* 49ий: input - поле типу "submit" призначене для відправки даних форми на сервер; по атрибуту "name" можемо на сервері ідентифікувати, яка саме кнопка була натиснута при відправці даних; атрибут "value" використовується для тексту на кнопці; також відправити дані на сервер можна натиснувши кнопку "Enter" маючи сфокусованим одне із полів форми; при цьому буде автоматично запущена перша кнопка на формі;
* 50ий: button - аналогічно до поля input з типом "submit", можна використовувати тег button; він аналогічний по функціоналу, але кращий у випадку, якщо потрібно додати кастомні стилі до кнопки.

Зберігаємо оновлений шаблон і оновляємо сторінку в браузері:

![Базова форма додавання студента](images/base_student_add_form.jpg)

Уже досить непогано! Тому переходимо до в'юшки і попрацюємо із Python кодом.

### Оновлюємо в'юшку

Першим ділом оновимо поле "Група" списком реальних груп із бази даних. Для цього передамо з в'юшки в шаблон список усіх груп:

{title="Передаємо групи в шаблон, students.py модуль в пакеті views.",lang="python"}
~~~~~~~~
from ..models import Student, Group

def students_add(request):
    return render(request, 'students/students_add.html',
        {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

Буквально одним рядочком ми отримали список усіх груп в базі даних посортованих по імені і передали їх під ключем 'groups'. Таким чином можемо тепер ним скористатись в шаблоні:

{title="Список існуючих груп готовий",lang="html"}
~~~~~~~~
<select name="student_group" id="student_group">
  <option value="">Виберіть групу</option>
  {% for group in groups %}
  <option value="{{ group.id }}">{{ group.title }}</option>
  {% endfor %}
</select>
~~~~~~~~

В 3му рядку ми пробігаємось в циклі по списку "groups". В тілі даного циклу ми створюємо теги "option", значеннями яких є унікальні ідентифікатори груп (id), а ім'я групи використовуємо для візуального представлення користувачеві.

Спробуйте тепер перевантажити вашу сторінку і переконайтесь, що випадайка з групами відображає існуючі групи з бази даних.

В даний момент наша в'юшка вміє лише показувати форму додавання студента, але ще не вміє обробляти пост даної форми. Наша задача полягає в тому, щоб навчити дану в'юшку:

* перевіряти чи відбувся пост форми;
* якщо відбувся, тоді перевірити вхідні дані;
* якщо дані правильні, створити і зберегти нового студента в базу;
* вернутись на список із студентами;
* якщо дані неправильні, вернути форму і вказати користувачеві на вказані помилки;
* при цьому бажано залишити попередні значення полів введені користувачем;
* якщо пост форми відбувся, але кнопка "Відмінити" була натиснута, тоді просто переводимо користувача на сторінку із списком студентів;
* якщо ж поста форми не було, просто показуємо початкову порожню форму.

Давайте почнемо малими кроками оновлювати нашу в'юшку. Найкращим варіантом буде почати із метакоду - додати коментарі щодо загальної логіки (так як ми це описали у списку вище) до коду в'юшки:

{title="Реалізуємо в'юшку на метакоді",lang="python"}
~~~~~~~~
def students_add(request):
    # Якщо форма була запощена:

        # Якщо кнопка Скасувати була натиснута:
        
            # Повертаємо користувача до списку студентів
        
        # Якщо кнопка Додати була натиснута:
        
            # Перевіряємо дані на коректність та збираємо помилки
            
            # Якщо дані були введені некоректно:
                # Віддаємо шаблон форми разом із знайденими помилками
            
            # Якщо дані були введені коректно:
                # Створюємо та зберігаємо студента в базу
                
                # Повертаємо користувача до списку студентів

    # Якщо форма не була запощена:
        # повертаємо код початкового стану форми
        return render(request, 'students/students_add.html',
            {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

Для чого ми це робимо? Для того, щоб отримати повну картину необхідної логіки, і вже потім, маючи загальний потік дій у в'юшці, по-трохи заповнювати реальним кодом. Таким чином, ми ітеративно розширюватимемо нашу функцію щораз складнішим кодом.

A> Рекомендую використовувати даний підхід "метакоду" у власній щоденній практиці. Він допоможе вам із самого початку краще моделювати ваш код, API та архітектуру ваших проектів.

Почнемо із найпростіших речей: перевірка на пост форми, а також збереження студента. А валідацію даних залишимо на кінець, оскільки це буде найскладніша частина логіки нашої в'юшки.

Ось як виглядатиме код функції з оновленими умовами:

{title="Додаємо перевірку на сабміт форми та додаємо студента",lang="python"}
~~~~~~~~
from django.shortcuts import render
from django.http import HttpResponse, HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger

from ..models import Student, Group

def students_add(request):
    # was form posted?
    if request.method == "POST":
        # was form add button clicked?
        if request.POST.get('add_button') is not None:

            # TODO: validate input from user
            errors = {}

            if not errors:
              # create student object
              student = Student(
                  first_name=request.POST['first_name'],
                  last_name=request.POST['last_name'],
                  middle_name=request.POST['middle_name'],
                  birthday=request.POST['birthday'],
                  ticket=request.POST['ticket'],
                  student_group=
                      Group.objects.get(pk=request.POST['student_group']),
                  photo=request.FILES['photo'],
              )

              # save it to database
              student.save()

              # redirect user to students list
              return HttpResponseRedirect(reverse('home'))

            else:
                # render form with errors and previous user input
                return render(request, 'students/students_add.html',
                    {'groups': Group.objects.all().order_by('title'),
                     'errors': errors})
        elif request.POST.get('cancel_button') is not None:
            # redirect to home page on cancel button
            return HttpResponseRedirect(reverse('home'))
    else:
        # initial form render
        return render(request, 'students/students_add.html',
            {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

Ми замінили практично весь метакод окрім валідації даних. То ж, що саме ми зробили:

* 2ий рядок: імпортуємо HttpResponseRedirect клас, який використовуватимемо для редіректу браузера на сторінку із списком студентів при успішній обробці форми;
* 11ий: POST - перевіряємо чи форма була відправлена; в такому випадку метод запиту буде "POST";
* 13ий: перевіряємо чи була натиснута кнопка Додати Студента; так, кнопки форми також потрапляють в словник POST об'єкта запиту; ось чому важливо коректно встановити атрибут "name" для тегу кнопки;
* 15ий: залишаємо коментар TODO (завдання на майбутнє), щоб пізніше не забути додати сюди логіки по валідації даних з форми; ми визначили змінну-словник errors, в яку пізніше додаватимемо знайдені помилки; а поки він у нас порожній;
* 18ий: перевіряємо чи немає помилок валідації даних;
* 20ий: якщо помилок таки немає (тобто словник errors порожній), створюємо об'єкт студента; йому передаємо дані із словника POST; оскільки наша форма має метод 'POST', то і дані на сервер прийшли у словнику POST; якщо б форма працювала через метод 'GET', тоді, відповідно, ми б мали працювати на сервері із атрибутом GET об'єкта запиту;
* 26ий: як ви вже знаєте, поле моделі ForeignKey вимагає в якості значення об'єкт класу моделі; саме тому в даному рядку ми отримуємо з бази даних групу ідентифіковану через поле 'student_group'; дане поле є рівним "ID" полю групи; метод "get" поверне нам єдиний унікальний об'єкт форми за даним "ID";
* 29ий: файли у формі приходять до нас по-іншому, ніж решта полів; а саме в атрибуті запиту "FILES"; 
* 33ій: зберігаємо новоствореного студента в базу даних; на цьому етапі, якщо передані дані є некоректними, або певних обов'язкових полів моделі бракує, отримаємо помилку; тому для тесту даного коду, поки у нас немає валідації, введіть усі поля на формі правильним чином;
* 36ий: після успішного збереження студента перенаправляємо користувача на список студентів; для цього повертаємо із нашої функції об'єкт класу HttpResponseRedirect з переданим йому параметром: адресою сторінки, на яку перенаправити користувача; дану адресу ми сформували з допомогою функції reverse, яку імпортували на початку модуля; мінімальний набір аргументів даної функції - це назва URL шаблона, який ми задекларували у модулі urls.py; функція reverse є аналогом шаблонного тегу url;
* 38ий: починаємо гілку коду, яка виконується при невдалій валідація вводу від користувача;
* 40ий: у цьому випадку ми повторно показуємо форму додавання студента, але цього разу ще й передаємо в шаблон наш словник із помилками "errors"; пізніше, коли матимемо валідацію, також оновимо шаблон, щоб він правильно використовував дані помилки для відображення користувачеві;
* 43ій: перевіряємо чи користувач натиснув кнопку "Скасувати";
* 45ий: якщо так, тоді просто перенаправляємо користувача на сторінку із списком студентів;
* 46ий: наша початкова гілка: відображаємо початковий стан форми, якщо тип запиту не є "POST".

A> *HTTP редірект* - це перенаправлення браузера на іншу сторінку. Всередині даний редірект відбувається з допомогою HTTP заголовка "Location", якому передають, в якості значення, URL адресу на іншу сторінку. Даний заголовок встановлюється сервером і зазвичай використовується після успішної обробки форми.

Спробуйте тепер перезавантажити вашу сторінку з формою додавання студента, заповнити усі поля коректними даними (поле дати заповніть у форматі [рік]-[місяць]-[день], напр. "1992-10-30") та натисніть кнопку Додати. Ви повинні перейти на сторінку списку студентів і там, в самому кінці списку, знайти вашого новододаного студента. Зайдіть в адмін частину Django сайту і переконайтесь, що усі введені вами поля є присутні в об'єкті студента.

A> Натомість отримали помилку "CSRF verification failed. Request aborted."? Так і було задумано ;-) Як ми уже з вами розібрались в першій секції даної глави, Django фреймворк обов'язково перевіряє кожну форму на наявність певного коду, щоб уникати CSRF хаку. Щоб доробити нашу форму для даної валідації просто додайте ось цей тег де-небудь всередині тегу form: "{% csrf_token %}". Він вставить для нас приховане поле із наперед згенерованим кодом для подальшої верифікації при пості форми. Тепер має усе працювати.

Також спробуйте скористатись кнопкою Скасувати. Ви маєте повернутись на список студентів, але цього разу без жодних змін у базу даних.

Якщо щось не виходить як описано вище, перегляньте код наведений в книзі, перегляньте ваш власний код і спробуйте запустити. В кінці кінців, гляньте в код, що йде разом із книгою і порівняйте, що у вас не так.

### Валідація даних

Переходимо до валідації. Валідація є однією із найвідповідальніших частин роботи із формою, і, водночас, однією із найважчих. Якщо недогледіти і пропустити дрібний момент, то можна залишитись із поламаною базою чи веб-сайтом.

Для більш-менш пристойної валідації на нашій формі нам потрібно:

* позначити обов'язкові поля на формі;
* перевірити поля на коректно введені дані;
* кожне невірно введене поле, або поле, яке є обов'язковим для введення, але користувач його пропустив, повинне бути згаданим в словнику 'errors'; в даному словнику ми вписуватимемо ключі одноіменні з назвами полів, а значеннями будуть стрічки тексту (повідомлення) для користувача з деталями помилок;
* якщо є хоча б одна помилка, тоді віддаємо шаблон форми;
* при цьому показуємо помилки біля кожного поля із некоректними даними;
* а також, для зручності користувача, зберігатимемо в полях форми попередньо введені дані; інакше користувачеві прийдеться щоразу вводити навіть ті дані, які були введені коректно попереднього разу.

Почнемо із простого, позначимо усі обов'язкові поля на формі додатковою зірочкою, що йде одразу після тексту мітки:

{title="Відмічаємо зірочкою поле Ім'я",lang="html"}
~~~~~~~~
  <div>
    <label for="first_name">Ім'я*</label>
    <input type="text" value=""
           name="first_name" id="first_name" />
  </div>
~~~~~~~~

В другому рядку можете бачити символ зірочки одразу після слова "Ім'я". Додайте також таку зірочку до усіх обов'язкових полів моделі Student: Ім'я, Прізвище, Дата Народження, Білет та Група.

Тепер користувач знатиме, що дані поля є обов'язковими і це збереже йому кілька секунд повторної відправки даних форми.

Наступним кроком додамо в нашу в'юшку Python код, який перевірятиме усі обов'язкові поля і повертатиме помилки, якщо їх бракуватиме:

{title="Валідуємо обов'язкові поля",lang="python",starting-line-number=15}
~~~~~~~~
            # errors collection
            errors = {}
            # validate student data will go here
            data = {'middle_name': request.POST.get('middle_name'),
                    'notes': request.POST.get('notes')}

            # validate user input
            first_name = request.POST.get('first_name', '').strip()
            if not first_name:
                errors['first_name'] = u"Ім'я є обов'язковим"
            else:
                data['first_name'] = first_name

            last_name = request.POST.get('last_name', '').strip()
            if not last_name:
                errors['last_name'] = u"Прізвище є обов'язковим"
            else:
                data['last_name'] = last_name

            birthday = request.POST.get('birthday', '').strip()
            if not birthday:
                errors['birthday'] = u"Дата народження є обов'язковою"
            else:
                data['birthday'] = birthday

            ticket = request.POST.get('ticket', '').strip()
            if not ticket:
                errors['ticket'] = u"Номер білета є обов'язковим"
            else:
                data['ticket'] = ticket

            student_group = request.POST.get('student_group', '').strip()
            if not student_group:
                errors['student_group'] = u"Оберіть групу для студента"
            else:
                data['student_group'] = Group.objects.get(pk=student_group)

            photo = request.FILES.get('photo')
            if photo:
                data['photo'] = photo

            # save student
            if not errors:
                student = Student(**data)
                student.save()

                # redirect to students list
                return HttpResponseRedirect(reverse('home'))
            else:
                # render form with errors and previous user input
                return render(request, 'students/students_add.html',
                    {'groups': Group.objects.all().order_by('title'),
                     'errors': errors})
~~~~~~~~

Вище наведено лише частину в'юшки додавання студента. Ту частина, де ми мали "TODO" нотатку для подальшого коду валідації.

Давайте пройдемось детальніше по останніх оновленнях:

* 16ий рядок: декларуємо змінну-словник для збору знайдених помилок;
* 18ий: в словник data будемо збирати коректні і нормалізовані дані з форми; ми одразу у ньому прописали два поля, які не потребують додаткової валідації: Нотатки та По-батькові;
* 22ий: витягуємо ім'я студента із форми (атрибуту POST) і обрізаємо по краях непотрібні пробіли; таким чином не пропускаємо від користувача стрічки, що міститиме лише пробіли;
* 23ій: перевіряємо чи стрічка не є порожньою;
* 24ій: якщо порожня, тоді додаємо в словник errors під ключем назви поточного поля стрічку-повідомлення про помилку;
* 26ий: якщо поле імені введене коректно, то додаємо його до словника data, на базі якого пізніше створимо об'єкт студента;
* 28ий: подібну річ проробляємо із полями Прізвище, День Народження, Білет, Група та полем Фото;
* 62ий: як бачите, тепер ми не витягуємо усі змінні ще раз із POST, а натомість використовуємо уже готовий для нас словник data; з допомогою спеціального синтаксису двох зірочок ми можемо функції передати розгорнутий в keyword аргументи словник; ефект буде такий самий як і при передачі напряму аргументів "first_name=" i т.д.;
* 71ий: якщо є помилки, то передаємо їх в шаблон із формами.

Тепер давайте оновимо наш шаблон так, щоб скористатись переданими помилками:

{title="Виводимо помилки на форму",lang="html"}
~~~~~~~~
  <div>
    <label for="first_name">Ім'я*</label>
    <input type="text" value=""
           name="first_name" id="first_name" />
    <span class="help-block">{{ errors.first_name }}</span>
  </div>
~~~~~~~~

До поля "Ім'я" ми додали ще один тег. Цього разу це span із класом [help-block](http://getbootstrap.com/css/#forms-control-validation). Всередині нього можете бачити змінну "errors.first_name". Із словника errors ми пробуємо витягнути ключ "first_name". Якщо його не існує, шаблон тихо проігнорує дану проблему без будь-яких помилок про неіснуючий ключ.

Додайте самостійно подібний span тег до усіх полів, при цьому змінивши ключ на назву відповідного поля.

Після цього оновіть сторінку із формою в браузері. Не вводіть ніяких даних та натисніть кнопку Додати. В результаті даної дії ви повинні залишитись на формі, але тепер форма дає вам знати деталі помилок вводу:

![Базова валідація форми працює](images/student_add_validate_base.jpg)

Гаразд. Базова валідація є, показується на формі для користувача і форму ми не пропускаємо на запис даних, якщо є некоректні дані. Але нам бракує ще більш розширених перевірок. Зокрема, для поля дати нам потрібно перевіряти чи формат стрічки є правильним.

Для поля групи потрібно перевіряти чи група існує в базі. Інакше наша в'юшка просто ламатиметься замість того, щоб повертати форму із гарними повідомленнями про помилки.

Ось повний оновлений код функції в'юшки форми додавання студента:

{title="Код із розширеною валідацією даних",lang="python"}
~~~~~~~~
# новий імпорт в модулі
from datetime import datetime

def students_add(request):
    # was form posted?
    if request.method == "POST":
        # was form add button clicked?
        if request.POST.get('add_button') is not None:
            # errors collection
            errors = {}

            # data for student object
            data = {'middle_name': request.POST.get('middle_name'),
                    'notes': request.POST.get('notes')}

            # validate user input
            first_name = request.POST.get('first_name', '').strip()
            if not first_name:
                errors['first_name'] = u"Ім'я є обов'язковим"
            else:
                data['first_name'] = first_name

            last_name = request.POST.get('last_name', '').strip()
            if not last_name:
                errors['last_name'] = u"Прізвище є обов'язковим"
            else:
                data['last_name'] = last_name

            birthday = request.POST.get('birthday', '').strip()
            if not birthday:
                errors['birthday'] = u"Дата народження є обов'язковою"
            else:
                try:
                    datetime.strptime(birthday, '%Y-%m-%d')
                except Exception:
                    errors['birthday'] = \
                        u"Введіть коректний формат дати (напр. 1984-12-30)"
                else:
                    data['birthday'] = birthday

            ticket = request.POST.get('ticket', '').strip()
            if not ticket:
                errors['ticket'] = u"Номер білета є обов'язковим"
            else:
                data['ticket'] = ticket

            student_group = request.POST.get('student_group', '').strip()
            if not student_group:
                errors['student_group'] = u"Оберіть групу для студента"
            else:
                groups = Group.objects.filter(pk=student_group)
                if len(groups) != 1:
                    errors['student_group'] = u"Оберіть коректну групу"
                else:
                    data['student_group'] = groups[0]


            photo = request.FILES.get('photo')
            if photo:
                data['photo'] = photo

            # save student
            if not errors:
                student = Student(**data)
                student.save()

                # redirect to students list
                return HttpResponseRedirect(reverse('home'))
            else:
                # render form with errors and previous user input
                return render(request, 'students/students_add.html',
                    {'groups': Group.objects.all().order_by('title'),
                     'errors': errors})
        elif request.POST.get('cancel_button') is not None:
            # redirect to home page on cancel button
            return HttpResponseRedirect(reverse('home'))
    else:
        # initial form render
        return render(request, 'students/students_add.html',
            {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

То ж, що змінилось в нашій функції:

* 34ий рядок: ми оновили гілку валідації поля Дати Народження; тепер ми не лише перевіряємо на наявність дане поле, але і на правильний формат; для цього ми використовуємо напередодні імпортований модуль datetime (це вбудований модуль мови Python) та користуємось функцією strptime, щоб спробувати перетворити стрічку в Python datetime об'єкт; якщо стрічка не задовольняє вказаного формату, дана функція викине помилку; саме тому ми огорнули її виклик в "try/except" гілку; більше про роботу із датами в Python можете почитати [тут](http://asvetlov.blogspot.com/2012/10/format.html);
* 37ий: якщо передана стрічка дати неправильного формату, ми видаємо окреме повідомлення і нагадуємо про правильний формат для поля дати;
* 55ий: ми трохи оновили роботу із полем групи; ми дістаємо групу з бази даних через метод filter, що дозволить нам уникнути помилок в Python коді, якщо за даною ID (student_group) не виявиться групи в базі даних; груп із даною ID повинно бути рівно 1; якщо це не так, видаємо користувачу повідомлення, що група вибрана невірно.

Решта коду в даній функції залишилась незмінною.

A> На домашнє завдання реалізувати валідацію поля Фото. Файл фото повинен бути не більше 2 мегабайт у розмірі та бути дійсно файлом зображення. Підказка: найпримітивніший варіант валідації типу файла може бути по розширенню назви файла. Складніший і більш надійний метод буде валідація через вміст файла. Це можна зробити або з допомогою Python бібліотеки PIL, або використовуючи Django валідатор. Почніть із простішого варіанту, а далі спробуйте складніший. Складніший варіант вимагатиме від вас немалого часу для реалізації.

C> ...

Вам зручно кожного разу перенабирати усі поля форми після кожної невдалої валідації даних? Мені також ні. Тому давайте, зробимо так, щоб усі попередньо введені дані залишались у формі, якщо валідація даних не пройшла.

Це робиться доволі просто. Генерація шаблону відбувається при обробці того ж запиту, що і запуск в'юшки. Відповідно, об'єкт запиту (request) буде однаковим як для в'юшки, так і для шаблона. Отже, маємо в шаблоні доступ до усіх даних з форми. Давайте вставимо в значення полів форми ті дані, що є в запиті:

{title="Зберігаємо дані користувача на формі після невдалої валідації",lang="html"}
~~~~~~~~
  <div>
    <label for="first_name">Ім'я*</label>
    <input type="text" value="{{ request.POST.first_name }}"
           name="first_name" id="first_name" />
    <span class="help-block">{{ errors.first_name }}</span>
  </div>
~~~~~~~~

Як бачите все доволі просто. Змінну "{{ request.POST.first_name }}" ми вставили значенням в атрибут "value" тегу input. Проробіть подібне оновлення усіх інших полів самостійно.

Думаю вас мало озадачити поле Група?...

Тег select заслуговує окремої уваги. Логіка із вибору потрібної опції в даному тезі потребує трохи більше коду:

{title="Встановлюємо попереднє значення у полі Група",lang="html"}
~~~~~~~~
<select name="student_group" id="student_group"
        class="form-control">
  <option value="">Виберіть групу</option>
  {% for group in groups %}
  <option value="{{ group.id }}" {% if group.id == request.POST.student_group|add:0 %}selected="1"{% endif %}>{{ group.title }}</option>
  {% endfor %}
</select>
~~~~~~~~

В тегу option ми додали тег умови. Якщо поточна група ітерації є рівна попередньо вибраній групі, тоді ми маркуємо поточний тег option як "selected". Зверніть увагу, що ми порівнюємо "id" об'єкта групи (дане поле є числом) із ключем "student_group" (який є юнікодовою стрічкою), що знаходиться в пості запиту. Тому, щоб перевести обидва операнди операції порівняння, ми додаємо фільтр "add:0" до змінної "student_group". Даний фільтр спробує додати до стрічки "student_group" нуль і результат поверне у вигляді числа. Цей хак ми застосували спеціально, щоб отримати з обох сторін знаку порівняння операнди типу integer.


A> Полю input типу "file" не можна ніяким чином встановити значення, окрім як користувач сам його вибере. Це обмеження зроблено спеціально для безпеки в інтернеті. Інакше ми б могли із сервера чи Javascript коду самостійно приєднати файл на формі із машини нашого користувача. Доступ до вашої файлової системи будь-яким веб-сайтом в інтернеті, самі розумієте, був би поганою ідеєю. Для обходу даного обмеження можна реалізувати Ajax форми без перевантаження сторінки, що дозволить користувачу не приєднувати файл кожного разу при введені некоректних даних на формі.

Таким чином ми з вами повністю розробили HTML код форми та логіку з її обробки. Дана логіка правильно обробляє обидві кнопки на формі, перевіряє дані форми, виводить помилки про некоректні дані, створює та зберігає студента та виводить попередні дані користувача у випадку помилок.

Наша форма практично готова. Залишилось зробити дві речі:

* додати глобальні статусні повідомлення про результати дій користувача із формою;
* заставити форму виглядати трохи краще із стилями від Twitter Bootstrap.

### Статусні повідомлення

На даний момент, коли ви додаєте студента або скасовуєте зміни, ви переходите на сторінку із списком студентів. Проте в обидвох випадках не зовсім зрозуміло, що насправді відбулось. Було б добре на цій сторінці показати повідомлення користувачеві про результат виконаних дій.

Саме це ми і зробимо у цій секції. Реалізуємо статусні повідомлення, які, на даний момент, працюватимуть згідно наступних тьох сценаріїв:

* якщо форма була відправлена на сервер, але виникли помилки валідації даних, ми показуємо статусне повідомлення і вказуємо користувачеві, що знайдено помилки на формі;
* якщо студент успішно доданий, показуємо повідомлення на сторінці із списком студентів;
* якщо натиснута кнопка "Скасувати", показуємо повідомлення, що зміни скасовано.

Реалізуємо дані повідомлення своїми силами. Для цього відкоментуємо наш давно забутий віджет "alert", який ми застилили згідно із [Twitter Bootstrap алертами](http://getbootstrap.com/components/#alerts).

Ось знайдений і відкоментований "alert" елемент в шаблоні base.html:

{title="Статусне повідомлення в base.html шаблоні",lang="html"}
~~~~~~~~
    <!-- Start Content Columns -->
    <div class="row" id="content-columns">
      <div class="col-xs-12" id="content-column">

        <div class="alert alert-warning" role="alert">Cтатусне повідомлення</div>

        <h2>{% block title %}{% endblock title %}</h2>
        {% block content %}{% endblock content %}

      </div>
    </div>
    <!-- End Content Columns -->
~~~~~~~~

В 5му рядку, як бачите, у нас є "Статусне повідомлення". Але поки воно лише статичне і постійно показуватиметься на сторінці.

Найпростішим підходом, щоб передавати повідомлення між сторінками при редіректах, буде використання URL параметрів. Більшість запитів будуть запитами типу GET, відповідно, можемо перевіряти чи параметр присутній в запиті. Якщо так - показуємо наше повідомлення, а значення параметра вставляємо всередину тега алерта:

{title="Статусне повідомлення в base.html шаблоні",lang="html"}
~~~~~~~~
    <!-- Start Content Columns -->
    <div class="row" id="content-columns">
      <div class="col-xs-12" id="content-column">

        {% block status_message %}
        {% if request.GET.status_message %}
        <div class="alert alert-warning" role="alert">{{ request.GET.status_message }}</div>
        {% endif %}
        {% endblock %}

        <h2>{% block title %}{% endblock title %}</h2>
        {% block content %}{% endblock content %}

      </div>
    </div>
    <!-- End Content Columns -->
~~~~~~~~

Як бачите, змінну, в якій передаватимемо статусне повідомлення ми назвали "status_message". Якщо дана змінна присутня в запиті ("request.GET"), тоді показуємо елемент із алертом, а значення цієї змінної вставляємо всередині тегу. Окрім того, зауважте, що весь алерт є тепер огорнутим в іменований блок "status_message". Це нам пригодиться пізніше, коли треба буде по іншому вставляти дане повідомлення на тих сторінках, де у нас немає редіректу. А саме, на сторінці з формою додавання студента, коли валідація даних не проходить.

Тепер, коли наші шаблони готові до відображення повідомлень, залишилось навчити наші в'юшки редіректити на сторінки і при цьому передавати додатковий параметр "status_message".

Почнемо із редіректів, що відбуваються при успішному додаванні студента та при натисканні кнопки Скасувати:

{title="Додаємо status_message до в'юшки students_add",lang="python"}
~~~~~~~~
def students_add(request):
    # was form posted?
    if request.method == "POST":
        # was form add button clicked?
        if request.POST.get('add_button') is not None:
            # errors collection
            errors = {}

            # data for student object
            data = {'middle_name': request.POST.get('middle_name'),
                    'notes': request.POST.get('notes')}

            # validate user input
            first_name = request.POST.get('first_name', '').strip()
            if not first_name:
                errors['first_name'] = u"Ім'я є обов'язковим"
            else:
                data['first_name'] = first_name

            last_name = request.POST.get('last_name', '').strip()
            if not last_name:
                errors['last_name'] = u"Прізвище є обов'язковим"
            else:
                data['last_name'] = last_name

            birthday = request.POST.get('birthday', '').strip()
            if not birthday:
                errors['birthday'] = u"Дата народження є обов'язковою"
            else:
                try:
                    datetime.strptime(birthday, '%Y-%m-%d')
                except Exception:
                    errors['birthday'] = \
                        u"Введіть коректний формат дати (напр. 1984-12-30)"
                else:
                    data['birthday'] = birthday

            ticket = request.POST.get('ticket', '').strip()
            if not ticket:
                errors['ticket'] = u"Номер білета є обов'язковим"
            else:
                data['ticket'] = ticket

            student_group = request.POST.get('student_group', '').strip()
            if not student_group:
                errors['student_group'] = u"Оберіть групу для студента"
            else:
                groups = Group.objects.filter(pk=student_group)
                if len(groups) != 1:
                    errors['student_group'] = u"Оберіть коректну групу"
                else:
                    data['student_group'] = groups[0]


            photo = request.FILES.get('photo')
            if photo:
                data['photo'] = photo

            # save student
            if not errors:
                student = Student(**data)
                student.save()

                # redirect to students list
                return HttpResponseRedirect(
                    u'%s?status_message=Студента успішно додано!' %
                    reverse('home'))
            else:
                # render form with errors and previous user input
                return render(request, 'students/students_add.html',
                    {'groups': Group.objects.all().order_by('title'),
                     'errors': errors})
        elif request.POST.get('cancel_button') is not None:
            # redirect to home page on cancel button
            return HttpResponseRedirect(
                u'%s?status_message=Додавання студента скасовано!' %
                reverse('home'))
    else:
        # initial form render
        return render(request, 'students/students_add.html',
            {'groups': Group.objects.all().order_by('title')})
~~~~~~~~

Я навів повний код функції в'юшки додавання студента. Але змінені були лише два рядочки:

* 70ий рядок: до HttpResponseRedirect стрічки додали '?status_message=Студента успішно додано!'; зробили ми це з допомогою інтерполяцій стрічок в мові Python;
* 80ий: таким самим чином ми додали повідомлення при натиску кнопки Скасувати.

A> На домашнє завдання: додайте до статусного повідомлення про успішне створення студента ще й повне ім'я новоствореного об'єкта.

Ось як виглядатиме повідомлення про скасоване додавання студента:

![Статусне повідомлення](images/status_message.jpg)

Залишився ще один сценарій: статусне повідомлення про знайдені помилки на формі. Тут маємо дещо складнішу ситуацію, адже при неправильних даних ми не робимо редіректу, відповідно, і не можемо встановити URL параметр.

Зробіть паузу і подумайте як би ви реалізували дане повідомлення...

А тепер дивіться, який варіант я пропоную використати. Ми уже огорнули наше статусне повідомлення в тег блоку, тому можемо його повністю перекривати в кінцевому шаблоні. Це ми і зробимо в шаблоні students_add.html. В даному шаблоні ми також маємо доступну змінну "errors", згідно якої можемо визначати чи показувати повідомлення чи ні. А саме повідомлення можемо вписати статичним текстом, адже воно завжди матиме єдину причину: помилки на формі. Додайте наступний блок де-небудь в шаблоні students_add.html на кореневому рівні:

{title="Додаємо статусне повідомлення для форми додавання студента",lang="html"}
~~~~~~~~
{% block status_message %}
  {% if errors %}
  <div class="alert alert-warning" role="alert">
    Будь-ласка, виправте наступні помилки
  </div>
  {% endif %}
{% endblock status_message %}
~~~~~~~~

Думаю додаткових пояснень тут не потрібно. Таким чином маємо реалізовані усі три сценарія із статусними повідомленнями.

A> На домашнє завдання пропоную вам переробити статусні повідомлення з використанням вбудованої Django аплікації "django.contrib.messages". Вони спеціально призначені для даного завдання та надають як серверну логіку, так і тег для шаблонів, щоб з легкістю і гнучко відображати статусні повідомлення. Найпоширеніше їхнє застосування - це робота із формами.

### Стилі Twitter Bootstrap

На завершення даної секції приведемо нашу форму додавання студента до гарного вигляду. Як завжди, скористаємось готовенькими стилями з чудового фреймворка [Twitter Bootstrap](http://getbootstrap.com/css/#forms).

У нас є кілька вимог до вигляду форми:

* збільшити вертикальні відстані між полями форми;
* підрівняти мітки і поля між собою;
* зробити ширину полів однаковою;
* форма має змінювати ширину відповідно до ширини вікна браузера; тобто гарно виглядати і на десктопі, і на мобільному;
* мітки мають бути в одному рядку із полями;
* повідомлення про помилки мають бути червоного кольору, сигналізуючи, таким чином, про несправність;
* кнопку Додати зробити темно синьою, а кнопку Скасувати у вигляді лінка.

Для початку по-максимуму скористаємось маркапом Twitter Bootstrap форм і додамо усі необхідні класи і огортаючі елементи нашій формі:

* "form-horizontal" клас до тегу form;
* "form-control" клас до усіх полів форми;
* "form-group" до огортаючих div елементів наших полів;
* також до "form-group" класу додамо "has-error" клас у випадку, якщо поле має помилку під час валідації;
* до міток (тег "label") додамо клас "control-label";
* також до міток додамо позиційний клас "col-sm-2", вказавши займати їм 2 частини із 12-ти;
* а 10 частин займатимуть поля; для цього огорнемо наші теги полів (теги input, select, textarea) та тег з помилкою "span.help-block" в додатковий тег div, якому присвоємо клас "col-sm-10";
* класи "btn" i "btn-primary" до кнопки "Додати"; це надасть їй гарного синього кольору і дефолтних стилів бібліотеки;
* класи "btn" i "btn-link" до кнопки "Скасувати"; після цього вона матиме вигляд лінка; це непогано підходить для кнопок з відмінами дій.

Нічого свого ми не придумували, а лише узяли класи із Twitter Bootstrap стилів для форм і додали до наших тегів. Ось кінцевий результат оновленої форми:

{title="Наша форма із Twitter Bootstrap стилями",lang="html"}
~~~~~~~~
<form action="." method="post" enctype="multipart/form-data"
      role="form" class="form-horizontal">
  {% csrf_token %}

  <div class="form-group {% if errors.first_name %}has-error{% endif %}">
    <label for="first_name" class="col-sm-2 control-label">Ім'я*</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.first_name }}"
             name="first_name" id="first_name"
             class="form-control" />
      <span class="help-block">{{ errors.first_name }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.last_name %}has-error{% endif %}">
    <label for="last_name" class="col-sm-2 control-label">Прізвище*</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.first_name }}"
             name="last_name" id="last_name"
             placeholder="Введіть ваше прізвище"
             class="form-control" />
      <span class="help-block">{{ errors.last_name }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.middle_name %}has-error{% endif %}">
    <label for="middle_name"class="col-sm-2 control-label">По-батькові</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.first_name }}"
             name="middle_name" id="middle_name"
             class="form-control" />
      <span class="help-block">{{ errors.middle_name }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.birthday %}has-error{% endif %}">
    <label for="birthday"class="col-sm-2 control-label">Дата Народження*</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.birthday }}"
             name="birthday" id="birthday"
             placeholder="Напр. 1984-12-30"
             class="form-control" />
      <span class="help-block">{{ errors.birthday }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.photo %}has-error{% endif %}">
    <label for="photo"class="col-sm-2 control-label">Фото</label>
    <div class="col-sm-10">
      <input type="file" value="" name="photo" id="photo"
             class="form-control" />
      <span class="help-block">{{ errors.photo }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.ticket %}has-error{% endif %}">
    <label for="ticket"class="col-sm-2 control-label">Білет*</label>
    <div class="col-sm-10">
      <input type="text" value="{{ request.POST.ticket }}"
             name="ticket" id="ticket"
             class="form-control" />
      <span class="help-block">{{ errors.ticket }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.student_group %}has-error{% endif %}">
    <label for="student_group"class="col-sm-2 control-label">Група*</label>
    <div class="col-sm-10">
      <select name="student_group" id="student_group"
              class="form-control">
        <option value="">Виберіть групу</option>
        {% for group in groups %}
        <option value="{{ group.id }}" {% if group.id == request.POST.student_group|add:0 %}selected="1"{% endif %}>{{ group.title }}</option>
        {% endfor %}
      </select>
      <span class="help-block">{{ errors.student_group }}</span>
    </div>
  </div>
  <div class="form-group {% if errors.notes %}has-error{% endif %}">
    <label for="notes" class="col-sm-2 control-label">Додаткові Нотатки</label>
    <div class="col-sm-10">
      <textarea name="notes" id="notes" class="form-control">{{ request.POST.notes }}</textarea>
      <span class="help-block">{{ errors.notes }}</span>
    </div>
  </div>
  <div class="form-group">
    <label class="col-sm-2 control-label"></label>
    <div class="col-sm-10">
      <input type="submit" value="Додати" name="add_button"
             class="btn btn-primary" />
      <button type="submit" name="cancel_button"
              class="btn btn-link">Скасувати</button>
    </div>
  </div>
</form>
~~~~~~~~

Зверніть увагу на рядок під номером 5. Там ми вставляємо клас "has-error" лише при наявності помилки із полем Ім'я. Подібну річ ми проробили для усіх полів, щоб мати додаткові стилі помилки для тих полів, що не пройшли валідацію даних.

Оновіть сторінку в браузері і перегляньте стилі форми та стилі повідомлень із помилками. Залишилась одна річ: поля форми розтягнуті на усю ширину сторінки. Це може бути непоганим підходом на вужчих екранах, але на широких такі поля виглядають дещо занадто широкими.

Дану проблему ми доволі просто пофіксимо самостійно власним CSS кодом:

{title="Оновляємо стилі нашої форми, файл main.css",lang="css"}
~~~~~~~~
/* Form Styles */
textarea,
select,
input {
  max-width: 300px;
}
~~~~~~~~

Стилів досить небагато. Все, що ми зробили це: встановили максимальну ширину усіх полів до 300 пікселів. Таким чином ми не обрізали класного функціоналу Twitter Bootstrap, який робить нашу форму гарною на усіх ширинах екранів, а лише обмежили по максимальній ширині.

Знову оновіть сторінку з формою. Ось кінцевий результат наших старань:

![Форма додавання студента повністю завершена](images/student_add_form_styled.jpg)

A> І не забувайте про регулярні коміти в репозиторій коду.

Гарна робота! Перед тим як переходити до наступної секції пропоную зробити невелику паузу і більше поекспериментувати із матеріалом даної секції. Адже тут ми розібрались із основами роботи із формами. Далі ми з вами продовжимо будувати форми, але з кожною новою секцією даної глави все більше і більше роботи за нас робитиме фреймворк Django.

## Форма контакту адміністратора

Ми не одразу стрибатимемо від повністю ручної форми додавання студента до повністю автоматичної форми редагування студента, побудованої з допомогою Django форм моделей.

Щоб краще зрозуміти механізм побудови автоматично згенерованої форми, спочатку реалізуємо форму контакту адміністратора сайту. Її ми побудуємо на окремій закладці нашої аплікації "Контакт" i вона дозволить користувачам аплікації надсилати листа адміністратору.

Для цього ми скористаємось Django класом для форми. Цей клас для нас:

* згенерує HTML код полів форми;
* проробить валідацію полів згідно правил, на які ми йому вкажемо.

Нам залишиться лише отримати вже коректні дані і відправити листа поштою.

### Підключаємо нову закладку

Почнемо із побудови інфраструктури для нашої нової сторінки із формою контакту.

В urls.py модулі додамо новий шаблон, який обслуговуватиме нашу сторінку:

{title="URL адреса для форми контакту, urls.py модуль",lang="python"}
~~~~~~~~
    # Contact Admin Form
    url(r'^contact-admin/$', 'students.views.contact_admin.contact_admin',
        name='contact_admin'),
~~~~~~~~

Як бачимо із нового URL шаблона, нам потрібно додати новий модуль contact_admin.py в пакеті views аплікації students, а в модулі додати нову функцію-в'юшку contact_admin:

{title="Створюємо модуль contact_admin.py",lang="shell"}
~~~~~~~~
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/views
$ touch contact_admin.py
~~~~~~~~

Додаємо базовий код в'юшки, який, поки, буде лише повертати шаблон form.html. Даний шаблон лежатиме в підпапці contact_admin всередині папки із шаблонами:

{title="contact_admin в'юшка",lang="python"}
~~~~~~~~
from django.shortcuts import render

def contact_admin(request):
    return render(request, 'contact_admin/form.html', {})
~~~~~~~~

Відповідно, тепер маємо створити шаблон form.html, а ще краще, скопіювати його з існуючих шаблонів:

{title="Копіюємо шаблон students/students_add.html в contact_admin/form.html",lang="shell"}
~~~~~~~~
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/templates
$ mkdir contact_admin
$ cp students/students_add.html contact_admin/form.html
~~~~~~~~

Підредагуємо шаблон form.html і, на даний момент, блок content залишимо практично порожнім:

{title="База для шаблону із формою, form.html",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}

{% block meta_title %}Зв'язок із Адміністратором{% endblock meta_title %}

{% block title %}Зв'язок із Адміністратором{% endblock title %}

{% block content %}

Тут буде форма контакту.

{% endblock content %}
~~~~~~~~

На завершення побудови інфраструктури нової сторінки, всередині шаблону base.html, додамо нову закладку Контакт:

{title="Додаємо закладку Контакт",lang="html"}
~~~~~~~~
        <ul class="nav nav-tabs" role="tablist">
          <li role="presentation" {% if request.path == '/' %}class="active"{% endif %}><a href="{% url "home" %}">Студенти</a></li>
          <li role="presentation" {% if '/journal' in request.path %}class="active"{% endif %}><a href="/journal">Відвідування</a></li>
          <li role="presentation" {% if '/groups' in request.path %}class="active"{% endif %}><a href="{% url "groups" %}">Групи</a></li>
          <li role="presentation" {% if '/contact-admin' in request.path %}class="active"{% endif %}><a href="{% url "contact_admin" %}">Контакт</a></li>
        </ul>
~~~~~~~~

Зверніть увагу, що в тегу "url" ми скористались іменем URL шаблона, який напередодні прописали в модулі urls.py.

Ніби все. Перевантажуйте сміливо вашу аплікацію в браузері. Повинна з'явитись закладка Контакт, яка покаже порожню сторінку із заголовком: "Зв'язок із Адміністратором".

Тепер ми готові до реалізації самої форми.

### Клас форми

Автоматичні форми в Django будуємо подібно до того, як реалізували класи моделей. Нам потрібно визначити клас нашої форми, унаслідувати від правильного базового класу та набити клас списком необхідних полів.

A> Автоматичними називаємо ті форми, які генеруєють HTML код та надають усю валідацію даних без додаткового кастомного коду із сторони розробника.

Ось приклад нашої форми контакту із усіма необхідними для неї полями. Весь код класу форми, як і самої в'юшки, кладемо в contact_admin.py модуль:

{title="Клас форми контакту адміністратора",lang="python"}
~~~~~~~~
from django import forms

class ContactForm(forms.Form):
    from_email = forms.EmailField(
        label=u"Ваша Емейл Адреса")

    subject = forms.CharField(
        label=u"Заголовок листа",
        max_length=128)

    message = forms.CharField(
        label=u"Текст повідомлення",
        max_length=2560,
        widget=forms.Textarea)
~~~~~~~~

Як бачите ми задекларували клас ContactForm, який унаслідується із базового класу Form. Даний клас приходить із вбудованого в Django пакету: "django.forms". Все, що пов'язано із формами лежить у даному пакеті.

Далі в класі йде список полів, що нам потрібні на формі контакту:

* емейл адреса відправника;
* заголовок листа;
* та саме тіло повідомлення.

Декларація полів є аналогічною з тим, як ми набивали поля для класів моделей студента та групи. Але в даному випадку ми використовуємо класи полів, що приходять, знову ж таки, із пакету "django.forms". Ці поля трохи відрізняються від тих, що є моделях. [Тут](http://djbook.ru/rel1.7/ref/forms/fields.html) можна переглянути як співставляються дані поля із полями моделей, а також список усіх доступних полів форм.

Кожне поле має ряд аргументів для впливу на те, як поле виглядатиме на формі, який тип даних відповідатиме даному полю, яка валідація застосовуватиметься на сервері. Таким чином ми вказали, що хочемо мати Textarea віджет для поля "Текстове повідомлення". Це для того, щоб користувач міг відправляти цілі параграфи тексту в листі. Також можете бачити, що ми скористались спеціальним полем для емейл адреси відправника. Дане поле за нас зробить валідацію на коректний формат емейл адреси.

Крім генерації HTML коду форми та валідації даних, даний клас форми також перетворить дані, що прийшли від користувача в тілі поста, у Python типи. Таким чином нам не прийдеться робити це самим.

Якщо відчуваєте, що потребуєте трохи більше теоретичної бази по Django формах, тоді рекомендую ознайомитись із [офіційним введенням у форми](http://djbook.ru/rel1.7/topics/forms/index.html).


### Логіка відправки листа

Маючи заготовку шаблона та готовий клас форми контакту, можемо приступати до реалізації найцікавішої частини нашого завдання - логіка в'юшки по відправленню листа.

Одразу скажу вам, що коду буде значно менше, ніж ми писали для форми додавання студента, адже усю валідацію та форматування даних для нас зробить клас форми. Ось як виглядатиме кінцевий код модуля contact_admin.py:

{title="Завершена в'юшка відправки емейла адміну",lang="python"}
~~~~~~~~
# -*- coding: utf-8 -*-
from django.shortcuts import render
from django import forms
from django.core.mail import send_mail
from django.http import HttpResponseRedirect
from django.core.urlresolvers import reverse

from studentsdb.settings import ADMIN_EMAIL

class ContactForm(forms.Form):
    from_email = forms.EmailField(
        label=u"Ваша Емейл Адреса")

    subject = forms.CharField(
        label=u"Заголовок листа",
        max_length=128)

    message = forms.CharField(
        label=u"Текст повідомлення",
        widget=forms.Textarea)

def contact_admin(request):
    # check if form was posted
    if request.method == 'POST':
        # create a form instance and populate it with data from the request:
        form = ContactForm(request.POST)

        # check whether user data is valid:
        if form.is_valid():
            # send email
            subject = form.cleaned_data['subject']
            message = form.cleaned_data['message']
            from_email = form.cleaned_data['from_email']

            try:
                send_mail(subject, message, from_email, [ADMIN_EMAIL])
            except Exception:
                message = u'Під час відправки листа виникла непередбачувана ' \
                    u'помилка. Спробуйте скористатись даною формою пізніше.'
            else:
                message = u'Повідомлення успішно надіслане!'

            # redirect to same contact page with success message
            return HttpResponseRedirect(
                u'%s?status_message=%s' % (reverse('contact_admin'), message))

    # if there was not POST render blank form
    else:
        form = ContactForm()

    return render(request, 'contact_admin/form.html', {'form': form})
~~~~~~~~

Нас цікавить лише функція в'юшки:

* 24ий рядок: з цим ми уже стикались раніше; перевіряємо чи форма була відправлена постом;
* 27ий: створюємо об'єкт з класу форми, при цьому передаючи йому POST в якості аргумента; таким чином отримаємо "прив'язану" (англ. bound) форму до даних введених користувачем; це дозволить формі валідувати та конвертувати дані, а пізніше відобразити ці дані на формі при невдалій валідації;
* 30ий: по-справжньому чарівний рядок коду :-); виклик методу is_valid() на об'єкті форми заміняє нам усю валідацію даних, а також конвертацію даних у Python типи даних; даний метод повертає True, якщо валідація даних пройшла успішно, False - у протилежному випадку;
* 32ий: метод is_valid() "запихає" усі конвертовані дані з поста запиту в атрибут "cleaned_data"; краще використовувати дані із нього, аніж напряму із "request.POST", адже там вони уже правильно підготовані для нашого використання; таким чином отримуємо заголовок листа і зберігаємо його в змінну; аналогічно робимо із рештою полів форми;
* 36ий: розпочинаємо найцікавіше - відправку листа; дана процедура може викинути різноманітні помилки при контакті із сервером, що відправляє листи, тому варто огорнути наступний код гілкою "try/except";
* 37ий: на початку модуля ми імпортнули функцію send_mail із пакету "django.core.mail"; тепер ми скористаємось даною функцією; вона приймає наступні аргументи в даному порядку: заголовок листа, тіло листа, емейл адреса відправника, список отримувачів; адресу отримувача ми імпортнули із модуля settings.py проекту; далі ми налаштуємо емейл сервер, а також додамо дану змінну ADMIN_EMAIL до налаштувань; дана функція є надбудовою над Python функцією і полегшує роботу з відправки емейлів; також вона зчитує налаштування з модуля проекту для нас;
* 39ий: у випадку, якщо функція send_email поламалась при спробі відправки листа, ми перехоплюємо усі помилки і встановлюємо відповідне статусне повідомлення про поломку; дане повідомлення ми далі використаємо при редіректі;
* 44ий: якщо ж відправка відбулась успішно (так, "try/except" мають ще й гілку "else"), ми також встановлюємо статусне повідомлення, але тепер про позитивний результат відправки листа;
* 48ий: незалежно від результату ми редіректимо назад на форму контакту, при цьому показуючи статусне повідомлення встановлене раніше;
* 53ій: починаємо гілку коду, коли поста форми не було;
* 54ий: в такому випадку ми також створюємо об'єкт з класу форми, але цього разу не передаємо йому даних із запиту; таким чином форма буде порожньою на сторінці;
* 56ий: віддаємо шаблон сторінки, передаючи об'єкт форми.

Зауважте: якщо форма буде запощена, але дані не будуть проходити валідацію, тоді в шаблон ми передамо "прив'язану" форму (тобто форму з даними від попереднього запиту). Таким чином, при некоректно введених даних, користувач отримає заповнені поля і матиме змогу виправити помилки без повторного введення усіх полів.

Тепер, коли уся логіка функції в'юшки на місці, маємо зробити ще дві речі, щоб заставити це все запрацювати:

* налаштувати сервер відправки емейлів;
* оновити шаблон, щоб використовував передану йому форму, а також правильно відображав статусні повідомлення.

### SMTP сервер відправки листів

Дана секції не включає детальне налаштування самого SMTP сервера (сервера з відправки листів), а лише надає огляд кількох варіантів відправки листів. Тут ми сфокусуємось над тим, як і де правильно прописати деталі вашого підготованого сервера в коді нашого Django проекту.

A> Завдання щодо налаштування власного SMTP сервера залишається вам на самостійне опрацювання.

Функція send_mail, яку ми використовуємо для відправки листів, потребує кількох налаштованих змінних в модулі settings.py проекту:

* EMAIL_HOST: адреса вашого SMTP сервера;
* EMAIL_PORT: порт SMTP сервера;
* EMAIL_HOST_USER: ім'я користувача, якщо доступ до сервера закритий;
* EMAIL_HOST_PASSWORD: пароль користувача, якщо доступ до сервера закритий;
* EMAIL_USE_TLS: чи використовувати безпечне TLS з'єднання під час контакту SMTP сервера; це залежить від типу сервера і його налаштувань;
* EMAIL_USE_SSL: взаємовиключна опція із EMAIL_USE_TLS; якщо одна з них включена, тоді інша обов'язково має бути виключена; якщо не впевнені, який саме режим безпеки працює на вашому SMTP сервері - пробуйте різні комбінації перемикання даних опцій, а також варіант, коли обидві виключені.

Також в settings.py потрібно додати змінну ADMIN_EMAIL, яка вказуватиме на емейл адресу адміністратора нашої веб-аплікації:

{title="Приклад налаштувань SMTP сервера",lang="python"}
~~~~~~~~
# email settings
# please, set here you smtp server details and your admin email
ADMIN_EMAIL = 'admin@studentsdb.com'
EMAIL_HOST = 'smtp.server.com'
EMAIL_PORT = '587'
EMAIL_HOST_USER = 'username1'
EMAIL_HOST_PASSWORD = '********'
EMAIL_USE_TLS = True
EMAIL_USE_SSL = False
~~~~~~~~

Взалежності від того, як налаштуєте ваш SMTP сервер (або яким зовнішнім сервером скористаєтесь), відповідно прийдеться оновити значення даних змінних.

Є як мінімум три варіанта для відправки листів:

**Скористатись SMTP сервером вашого поштовика**

Якщо у вас, наприклад, є екаунт на gmail.com, тоді ви можете скористатись ним для відправки листів із нашої аплікації.

На [даній сторінці](http://ru.email-unlimited.com/help/mailer/smtp-settings-samples.html) ви можете знайти деталі доступу і використання Gmail SMTP сервера, а також інших популярних емейл сервісів.

Ось приклад моїх налаштувань у випадку використання Gmail сервера для відправки листів:

{title="Приклад налаштувань для Gmail SMTP сервера",lang="python"}
~~~~~~~~
# email settings
# please, set here you smtp server details and your admin email
ADMIN_EMAIL = 'admin@studentsdb.com'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = '465'
EMAIL_HOST_USER = 'vitaliypodoba@gmail.com'
EMAIL_HOST_PASSWORD = '********'
EMAIL_USE_TLS = False
EMAIL_USE_SSL = True
~~~~~~~~

**Спеціалізований сервіс відправки листів**

Також існує маса зовнішніх сервісів для відправки листів. Вони надають SMTP сервер для використання і, так само як і з вашим поштовиком, вам залишається лише додати деталі сервера в модуль налаштування проекту.

Я рекомендую оглянути наступні сервіси:

* https://mandrillapp.com - користуюсь ним найбільше в даний момент;
* https://sendgrid.com/ - один із найпопулярніших сервісів розсилки листів на даний момент;
* http://www.icontact.com/ - ще один непоганий сервіс відправки листів.

Зареєструйтесь на одному із них. Відправка невеликої кількості емейлів зазвичай є безкоштовною. Для тестування точно вистачить. Після реєстрації налаштуйте сервіс та отримайте дані доступу до його SMTP серверу.

Ось як виглядатиме приклад моїх налаштувань через сервіс Mandrill:

{title="Приклад налаштувань для Mandrill SMTP сервера",lang="python"}
~~~~~~~~
# email settings
# please, set here you smtp server details and your admin email
ADMIN_EMAIL = 'admin@studentsdb.com'
EMAIL_HOST = 'smtp.mandrillapp.com'
EMAIL_PORT = '587'
EMAIL_HOST_USER = 'vitaliypodoba@gmail.com'
EMAIL_HOST_PASSWORD = '********'
EMAIL_USE_TLS = True
EMAIL_USE_SSL = False
~~~~~~~~

**Власний SMTP сервер**

Вкінці-кінців можете спробувати встановити і налаштувати власний SMTP сервер на локальній машині.

На Лінуксі одними із найпопулярніших є [sendmail](http://uk.wikipedia.org/wiki/Sendmail) та [postfix](http://uk.wikipedia.org/wiki/Postfix).

Якщо дійсно хочете спробувати даний варіант, тоді інсталяція та конфігурація даних серверів залишається вам повністю на самостійне опрацювання.

Після успішного налаштування власного SMTP сервера ваш settings.py модуль повинен містити щось подібне на:

{title="Приклад налаштувань локального SMTP сервера",lang="python"}
~~~~~~~~
# email settings
# please, set here you smtp server details and your admin email
ADMIN_EMAIL = 'admin@studentsdb.com'
EMAIL_HOST = 'localhost'
EMAIL_PORT = '25'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_USE_TLS = False
EMAIL_USE_SSL = False
~~~~~~~~

Думаю ви не будете налаштовувати ні доступ по користувачу, ні безпечні протоколи.

C> ...

[Тут](http://djbook.ru/rel1.7/ref/settings.html#email-host) можете знайти більше деталей про конфігурацію налаштувань для сервера відправки листів.

А на [даній сторінці](http://djbook.ru/rel1.7/topics/email.html) є непоганий вступ по роботі із листами в Django.

Якщо все зробили правильно, то за 30 хвилин матимете код по відпраці листа готовий.

### Оновлюємо шаблон форми

Залишилось зовсім небагато, щоб закінчити із відправкою листів: оновити шаблон, де скористатись формою, яку нам передає в'юшка.

Нам потрібно оновити два блоки: content та status_message. І почнемо ми із важливішого - блоку content.

Об'єкт форми надає нам кілька корисних методів для генерації HTML коду форми:

* {{ form.as_p }}: огортає поля (мітку + поле вводу) в теги параграфів (p);
* {{ form.as_table }}: представляє форму у вигляді таблиці;
* {{ form.as_ul }}: представляє поля у вигляді списку (теги "ul/li");
* ну і на кінець: якщо вставити об'єкт форми в шаблон без використання вищеперечислених методів, тоді теги полів не будуть огорнуті в жодні додаткові теги.

Ще хочу звернути вашу увагу на те, що форма не згенерує для нас самого тегу форми та кнопок, а лише HTML код для списку полів задекларованих в класі форми. Так само тег CSRF захисту потрібно вставити самостійно. Ось кінцевий результат блоку content:

{title="Додаємо форму контакту, contact_admin.form.html",lang="html"}
~~~~~~~~
{% block content %}

<form action="{% url "contact_admin" %}" method="post">
    {% csrf_token %}

    {{ form.as_p }}

    <input type="submit" value="Надіслати" name="send_button" />
</form>

{% endblock content %}
~~~~~~~~

Метод запиту форми POST, а зсилається форма сама на себе, адже наша в'юшка займається як генерацією форми, так і її обробкою.

Все решта, думаю, для вас є зрозумілим у вищенаведеному прикладі.

Уже на даний момент форма має бути повністю робочою. Статусні повідомлення щодо успішної відправки та поломки під час спроби відправити листа також уже мають працювати. Спробуйте потестувати функціонал форми. Якщо отримуєте помилку при спробі відправити валідні дані, повертайтесь у секцію з налаштування SMTP сервера і спробуйте полагодити значення змінних в модулі settings.py.

Але маємо ще один боржок щодо функціоналу форми. У випадку, якщо дані не пройшли валідацію, ми отримуємо помилки зверху некоректно введених полів, але немає глобального статусного повідомлення.

Для цього нам потрібно повністю перекрити блок status_message, що приходить із шаблону base.html під потреби нашої форми:

{title="Перекриваємо блок status_message",lang="html"}
~~~~~~~~
{% block status_message %}

{% if form.errors %}
  <div class="alert alert-warning" role="alert">
    Будь-ласка, виправте наступні помилки
  </div>
{% endif %}

{{ block.super }}

{% endblock %}
~~~~~~~~

Що ми зробили?

* 3ій рядок: усі назбирані помилки під час валідації даних від користувача форма для нас збирає в атрибут errors; тому ми скористались ним, щоб перевірити чи форма пройшла валідацію;
* 4ий: якщо є помилки, тобто валідація не пройшла, виводимо статичне повідомлення і просимо користувача виправити їх;
* 9ий: block.super - цікавий момент; нам потрібен кусок коду, який виводитиме статусні повідомлення, які ми передаємо під час редіректу в URL параметрі status_message; і щоб не дублювати коду із base.html, ми вставляємо його в кінцевий шаблон через "block.super"; атрибут "super" вказує на батьківський блок, який у нашому випадку є блоком із шаблону base.html.

A> Зверніть увагу на те, що автоматичні повідомлення про помилки на формі є уже для нас переведеними на українську мову. Це завдяки прописаній змінній "LANGUAGE_CODE = 'uk'" в модулі settings.py. Django форми уже мають український переклад інтерфейсу форм вкладений по-замовчуванню. Пізніше ми повернемось до цієї теми і повністю перекладемо нашу аплікацію на українську мову правильним чином.

Оновіть форму і ще раз потестуйте її. Весь функціонал на місці! Ось як виглядатиме ваша форма у випадку, якщо відбудеться помилка при валідації даних:

![Форма контакту адміна практично готова](images/contact_admin_form.jpg)

Єдине, що залишилось це додати гарні стилі.

### Стилі Twitter Bootstrap через Crispy Forms аплікацію

Знову залишився лише зовнішній вигляд форми. А саме:

* підрівняти мітки і поля;
* застилити стани із помилками в полях;
* застилити гарно кнопку.

Стилі знову ж таки візьмемо із бібліотеки Twitter Bootstrap. Але цього разу ми маємо далеко не повний контроль над HTML кодом форми. Відповідно потрібен інший підхід для стилізації.

Скористаємось однією з існуючих Django аплікацій, які надписують HTML стандартних Django форм кодом, що підходить під Twitter Bootstrap правила. Хорошим балансом між функціоналом та простотою у використанні володіє аплікація [Crispy Forms](https://readthedocs.org/projects/django-crispy-forms/). Нею ми і скористаємось, щоб "облагородити" нашу форму контакту.

Згідно [інсталяційної документації](http://django-crispy-forms.readthedocs.org/en/1.2.1/install.html) пакету під'єднаємо Crispy Forms до нашого проекту. Будемо використовувати останню стабільну версію - 1.4.0. Хоча вона і не згадана в документації, проте я знайшов її серед тегів в [репозиторії коду](https://github.com/maraujop/django-crispy-forms/tree/1.4.0). Відповідно, частину речей вам прийдеться вичитувати з коду, оскільки дещо може бути не включено у застарілу документацію аплікації.

Додамо пакет версії 1.4.0 в requirements.txt та заінсталюємо його у наше робоче середовище:

{title="requirements.txt",lang="shell"}
~~~~~~~~
Django==1.7.1
MySQL-python
Pillow
django-crispy-forms==1.4.0
~~~~~~~~

{title="Запускаємо інсталяцію пакетів",lang="shell"}
~~~~~~~~
# не забудьте перед даною командою активувати своє
# віртуальне середовище
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb
$ pip install -r requirements.txt
~~~~~~~~

Додаємо пакет crispy_forms у список заінстальованих аплікації:

{title="Додаємо crispy_forms до INSTALLED_APPS всередині settings.py модуля",lang="python"}
~~~~~~~~
INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'crispy_forms',
    'students',
)
~~~~~~~~

Конфігуруємо налаштування нової аплікації:

{title="settings.py",lang="python"}
~~~~~~~~
CRISPY_TEMPLATE_PACK = 'bootstrap3'
~~~~~~~~

Змінна "CRISPY_TEMPLATE_PACK" вказує аплікації Crispy Forms, які саме шаблони використовувати, адже вона містить не один набір для різних фреймворків. Нам, звичайно, потрібен останній Twitter Bootstrap: "bootstrap3".

Підключати CSS i Javascript файли не будемо, адже вони у нас вже давно підключені.

Тепер ми дійшли до найцікавішої частини - будемо додавати стилі до форми. Але будемо це робити у трохи незвичний спосіб: через Python код в класі форми, а не у шаблоні чи main.css файлі.

Crispy Forms дає нам два типи об'єктів для впливу на вигляд форми:

* [FormHelper клас](http://django-crispy-forms.readthedocs.org/en/latest/form_helper.html): власне через нього ми будемо робити усі наші зміни; його ми створимо в \_\_init\_\_.py методі класу форми;
* [лейаути](http://django-crispy-forms.readthedocs.org/en/latest/layouts.html): вони дозволяють змінювати теги та поля на формі, а також, наприклад, додавати кнопки на форму (адже по-замовчуванню форма буде без кнопок); нам буде потрібен лише один лейаут - леайут кнопки.

Ось як виглядатиме оновлений клас форми:

{title="Клас форми із crispy forms FormHelper об'єктом",lang="python"}
~~~~~~~~
from crispy_forms.helper import FormHelper
from crispy_forms.layout import Submit

class ContactForm(forms.Form):

    def __init__(self, *args, **kwargs):
        # call original initializator
        super(ContactForm, self).__init__(*args, **kwargs)

        # this helper object allows us to customize form
        self.helper = FormHelper()

        # form tag attributes
        self.helper.form_class = 'form-horizontal'
        self.helper.form_method = 'post'
        self.helper.form_action = reverse('contact_admin')

        # twitter bootstrap styles
        self.helper.help_text_inline = True
        self.helper.html5_required = True
        self.helper.label_class = 'col-sm-2 control-label'
        self.helper.field_class = 'col-sm-10'

        # form buttons
        self.helper.add_input(Submit('send_button', u'Надіслати'))
~~~~~~~~

У даному прикладі ми не наводили списку полів, адже вони залишились незмінними.

Давайте детальніше по-рядках проаналізуємо метод \_\_init\_\_.py:

* 1ий рядок: імпортуємо необхідний мінімум класів із crispy_forms аплікації; Submit - лейаут кнопки, яким ми далі в коді скористаємось;
* 11ий: створюємо об'єкт типу FormHelper і запам'ятовуємо його в атрибуті "helper" об'єкту форми; важливо, щоб атрибут мав саме дану назву, тоді Crispy Forms шаблонний тег підхопить нашого хелпера автоматично;
* 13ий: блок коду, де ми модифікуємо сам тег форми, встановлюючи йому клас, метод та атрибут 'action'; так, Crispy Forms згенерує для нас повну форму, включно з тегом form, CSRF захистом та кнопками; пізніше ми оновимо відповідно наш шаблон;
* 18ий: блок коду, де ми встановлюємо специфічні атрибути для Twitter Bootstrap бібліотеки, а саме: включаємо HTML5 атрибути валідації та додаємо класи Grid лейауту для мітки та поля, щоб краще розташувати елементи форми на сторінці;
* 25ий: додаємо з коду лейаут кнопки Submit; ця стрічка коду додасть нам кнопку "Надіслати" до форми із назвою "send_button".

Все, що потрібно зробити із змінами у формі, ми зробили. Тепер потрібно оновити наш шаблон, щоб він показував не стандартну, а кастомізовану форму, яка приходить із Crispy Forms HTML кодом.

Саме для цього дана аплікація надає тег "{% crispy [form_name] %}", якому потрібно передати об'єкт форми. Даний тег згенерує повний тег форми із усіма змінами, які ми занотували в Python коді.

Ось як доволі просто виглядатиме кінцевий шаблон:

{title="Шаблон форми використовує Crispy Forms",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}
{% load crispy_forms_tags %}

{% block meta_title %}Зв'язок із Адміністратором{% endblock meta_title %}

{% block title %}Зв'язок із Адміністратором{% endblock title %}

{% block status_message %}
{% if form.errors %}
  <div class="alert alert-warning" role="alert">
    Будь-ласка, виправте наступні помилки
  </div>
{% endif %}

{{ block.super }}
{% endblock %}


{% block content %}

{% crispy form %}

{% endblock content %}

~~~~~~~~

Що ми змінили:

* 4ий рядок: завантажили теги з Crispy Forms аплікації; по-замовчуванню зовнішні аплікації не підключають свої теги в шаблони;
* 24ий: викликали тег "{% crispy %}" і передали йому нашу форму.

Так просто ми отримали кінцеву форму. Тепер перезавантажте сторінку із формою і гляньте на результат:

![Форма контакту адміністратора із Crispy Forms](images/contact_admin_from_crispy.jpg)

Як бачите, форма уже виглядає значно краще. Crispy Forms аплікація на всі 100% задовольнила наші потреби.

A> На домашнє завдання: переробіть контакт форму з використанням вже існуючої Django аплікації: https://pypi.python.org/pypi/django-contact-form По-суті, вам практично не прийдеться розробляти кастомного коду, а лише інтегрувати існуючий у свою аплікацію.

C> ...

Тепер ми не лише вміємо з нуля створювати форму та працювати з нею, але й знаємо швидший шлях для отримання даних від користувача - Django форми. Будемо ще більше прискорюватись! Переходимо до Django форм створених спеціально для роботи із моделями.

## Форма редагування студента

Форма редагування, мабуть, буде найшвидшою формою, яку ми реалізуємо. Без написання HTML коду полів, практично без Python логіки, декларації полів і навіть класу форми! Все це за нас зробить форма Django для роботи з моделями.

Для в'юшки форми редагування студента ми вперше скористаємось не функцією, а класом. Тому давайте спочатку коротко оглянемо різницю між цими двома підходами, а також коли використовувати кожен із них.

### В'юшки Функції vs В'юшки Класи

В'юшки Класи ввели в Django відносно недавно. До цього ми могли створювати в'юшки лише використовуючи Python функції.

Основною задачею класів є зменшити дубльований код між в'юшками. Python класи дозволяють визначати абстрактні класи, в яких міститиметься повторюваний код, і потім унаслідуватись від цих класів у кінцевих в'юшках.

Програмування веб-сайтів це, досить часто, багато повторюваної роботи. Якраз таку повторювану роботу і спробували винести у наперед заготовані класи в'юшок в Django. Таким чином, якщо ваше завдання підпадає під категорію таких повторюваних рутин, тоді ви зможете зекономити масу часу, скориставшись готовим класом.

Ось список визначених для нас класів в Django:

* ListView: для виведення списку об'єктів з бази;
* DetailView: для відображення одного об'єкту з бази;
* RedirectView: для здійснення редіректу на іншу сторінку; так, навіть для цієї дії є окрема в'юшка-клас;
* CreateView: форма додавання нового об'єкта до бази;
* UpdateView: форма редагування існуючого об'єкта в базі;
* DeleteView: видалення об'єкта з бази;
* ArchiveIndexView, YearArchiveView, MonthArchiveView, WeekArchiveView, DayArchiveView, TodayArchiveView, DateDetailView: в'юшки для реалізації сторінок блогу.

Усі вищеперечислені класи певним чином використовують один із базових класів: FormView, View, TemplateView. До речі, класом TemplateView ми самі скористаємось під час реалізації закладки Відвідування.

**Клас чи Функція?**

Є три табора розробників у спільноті Django:

* ті, хто до останнього уникає класів; тобто завжди починають із функції, а далі переходять на клас, якщо вже немає куди діватись;
* ті, хто намагаються всюди "втулити" клас;
* ті, хто аналізує ситуацію, завдання і проект загалом, та кожного разу вирішує, що краще використати.

Я, особисто, надаю перевагу третьому табору, і кожного разу обираю той підхід, який краще пасуватиме під конкретну задачу. Ось кілька критеріїв, якими я керуюсь при цьому:

Якщо ваше завдання підпадає під стандартні задачі:

* відобразити об'єкт чи список об'єктів з бази даних;
* додати, поредагувати чи видалити об'єкт з бази;
* написати блог,

тоді використовуйте наперед заготовані в Django класи в'юшок.

Якщо ви повторюєте багато коду у різних функціях в'юшок в проекті, тоді виділіть цей код в базовий абстрактний клас, переробіть функції на класи і унаслідуйтесь від базового класу.

Якщо завдання ще не до кінця вам зрозуміле, тоді використовуйте функцію. Пізніше, при потребі, переїдете на клас.

Якщо маєте в'юшку у вигляді класу, але з часом кастомізувати її під потреби проекту стає все важче і важче. Тоді є зміст задуматись над поверненням на функцію, де ви будете вільні від будь-яких правил.

Ось і всі правила, якими я зазвичай керуюсь при виборі між класом та функцією для чергової в'юшки. З досвідом ваш вибір ставатиме швидшим і кращим.

**Робота із класами**

Робота із класами в якості в'юшок дещо відрізняється від того, як ми працювали із функціями. Класи дають нам багато наперед заготованого функціоналу, але і разом з тим багато обмежень і правил, які нам потрібно знати. Почнемо із огляду класів для відображення даних на сторінці, а потім перейдемо до класів роботи із формами.

При кожному запиті запускається функція в'юшки. А коли маємо справу із класами, тоді при кожному запиті створюється об'єкт із класу в'юшки і запускається її вбудований метод [dispatch](http://djbook.ru/rel1.7/ref/class-based-views/base.html#django.views.generic.base.View.dispatch). Цей метод унаслідуємо від вбудованих Django в'юшок. Даний метод запускає одноіменний метод з назвою типу запиту: get, post, head і т.д. Дані методи об'єкта класу можемо як використовувати по-замовчуванню із унаслідуваної базової в'юшки, так і описувати у власному класі при потребі.

Таким чином, для кожного аспекта обробки запиту, даних і формування відповіді, в Django класах в'юшок передбачені свої атрибути та методи класу. Потрібно знати набір найбільш популярних методів та атрибутів, щоб мати можливість їх кастомізувати на рівні власного класу.

Найбазовішим класом є [View](http://djbook.ru/rel1.7/ref/class-based-views/base.html#django.views.generic.base.View) і він має такі важливі для нас методи та атрибути:

* [as_view](http://djbook.ru/rel1.7/ref/class-based-views/base.html#django.views.generic.base.View.as_view): [статичний метод](https://docs.python.org/2/library/functions.html#staticmethod) (має декоратор staticmethod) використовується в URL шаблонах, адже ми не можемо напряму передати клас в url функцію в модулі urls.py;
* get, post, head і т.д.: для обробки запиту відповідного типу.

Клас [TemplateView](http://djbook.ru/rel1.7/ref/class-based-views/base.html#templateview) додатково підготує і віддасть у відповіді шаблон з HTML кодом:

* template_name: атрибут, що вказує на шлях до файлу шаблона;
* [get_context_data](http://djbook.ru/rel1.7/ref/class-based-views/mixins-simple.html#django.views.generic.base.ContextMixin.get_context_data): метод повертає словник із додатковими даними для шаблона.

Клас [RedirectView](http://djbook.ru/rel1.7/ref/class-based-views/base.html#redirectview):

* [get_redirect_url](http://djbook.ru/rel1.7/ref/class-based-views/base.html#django.views.generic.base.RedirectView.get_redirect_url): метод, що віддає URL адресу для редіректу;
* url: атрибут, в якому можна містити статичну стрічку-адресу для редіректу.

Клас [DetailView](http://djbook.ru/rel1.7/ref/class-based-views/generic-display.html#detailview) працює для генерації списку об'єктів із бази даних:

* [model](http://djbook.ru/rel1.7/ref/class-based-views/mixins-multiple-object.html#django.views.generic.list.MultipleObjectMixin.model): атрибут, який вказує на клас моделі, з яким працюватиме дана в'юшка;
* [get_queryset](http://djbook.ru/rel1.7/ref/class-based-views/mixins-single-object.html#django.views.generic.detail.SingleObjectMixin.get_queryset): метод, який задає кастомний запит в базу для отримання єдиного об'єкта заданого типу;
* get_context_data: такий самий метод, як і в TemplateView класі;
* get_object: повертає об'єкт із бази, який будемо представляли на сторінці.
* [render_to_response](http://djbook.ru/rel1.7/ref/class-based-views/mixins-simple.html#django.views.generic.base.TemplateResponseMixin.render_to_response)
* object: змінна доступна в шаблоні для отримання об'єкта, який відображаємо.

Клас [ListView](http://djbook.ru/rel1.7/ref/class-based-views/generic-display.html#django.views.generic.list.ListView), який використовуємо для відображення списку об'єктів із бази даних:

* [paginate_by](http://djbook.ru/rel1.7/ref/class-based-views/mixins-multiple-object.html#django.views.generic.list.MultipleObjectMixin.paginate_by): атрибут, який вказує на кількість елементів на сторінці; так, даний клас реалізує для нас посторінкову навігацію;
* [object_list](http://djbook.ru/rel1.7/ref/class-based-views/mixins-multiple-object.html#django.views.generic.list.MultipleObjectMixin.get_context_data): список об'єктів під даною назвою доступний в шаблоні;
* також даний клас передає шаблону змінні для роботи із посторінковою навігацією по списку: is_paginated, paginator, page_obj;
* усі інші методи подібні як у класі DetailView: get_context_data, get_queryset.

C> ...

Давайте тепер розглянемо невеличкий, швидше теоретичний, приклад класу в'юшки і його використання. Зробимо в'юшку списку студентів, але цього разу використовуючи класи. Скористаємось базовим класом ListView:

{title="Клас в'юшки списку студентів",lang="python"}
~~~~~~~~
from django.views.generic import ListView
from students.models.students import Student

class StudentList(ListView):
    model = Student
~~~~~~~~

Додамо дану в'юшку до URL шаблонів:

{title="Ось як лінкуються класові в'юшки в urls.py",lang="python"}
~~~~~~~~
from django.conf.urls import patterns, url
from students.views.students import StudentList

urlpatterns = patterns('',
    url(r'^student_list/$', StudentList.as_view()),
)
~~~~~~~~

І це увесь Python код, який нам потрібно писати для списку студентів. Залишився шаблон. Зробимо його дуже простим:

{title="Шаблон для списку студентів",lang="html"}
~~~~~~~~
{% extends "base.html" %}

{% block content %}
    <h2>Студенти</h2>
    <ul>
        {% for student in object_list %}
            <li>{{ studnet.last_name }}</li>
        {% endfor %}
    </ul>
{% endblock %}
~~~~~~~~

A> Клас в'юшки автоматично шукатиме за шаблоном із назвою "students/student_list.html", де "students" береться із назви аплікації, "student" - із назви моделі, "list" - із назви в'юшки "ListView". Або, альтернативно, можемо додати атрибут класу "template_name" до класу StudentList, щоб використати шаблон із іншою назвою.

В шаблоні ми скористались змінною "object_list", який нам передала в'юшка. Це є список усіх студентів в базі. Ми можемо обмежити даний список через get_queryset метод на класі в'юшки, а також можемо встановити додаткові дані для шаблону i ще декілька додаткових кастомізацій:

{title="Більше кастомізацій у класі в'юшки",lang="python"}
~~~~~~~~
from django.views.generic import ListView
from students.models.students import Student

class StudentList(ListView):
    model = Student
    context_object_name = 'students'
    template = 'students/student_class_based_view_template'

    def get_context_data(self, **kwargs):
        """This method adds extra variables to template"""
        # get original context data from parent class
        context = super(StudentList, self).get_context_data(**kwargs)

        # tell template not to show logo on a page
        context['show_logo'] = False

        # return context mapping
        return context 

    def get_queryset(self):
        """Order students by last_name."""
        # get original query set
        qs = super(StudentList, self).get_queryset()

        # order by last name
        return qs.order_by('last_name')
~~~~~~~~

В ускладненому класі ми:

* змінили назву змінної, що містить список студентів в шаблоні на "students";
* встановили кастомну назву шаблона через атрибут "template";
* додали змінну "show_logo" в контекст шаблона;
* змінили порядок студентів посортувавши їх по прізвищу.

**Класи для роботи із формами**

На завершення теоретичної частини про в'юшки-класи, розглянемо ще набір визначених для нас класів по роботі із формами.

Базовий клас для усіх в'юшок із формами називається [FormView](http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#django.views.generic.edit.FormView). Він відображає форму, показує помилки валідації і при успішній дії - редіректить на нову URL адресу. Ось основні атрибути і методи:

* подібні до атрибутів і методів, які ми уже з вами розглянули у попередніх класах: template_name, get, post, put, dispatch, as_view, get_context_data, model;
* fields: атрибут; вказує на список полів, які відобразити на формі;
* [form_class](http://djbook.ru/rel1.7/ref/class-based-views/mixins-editing.html#django.views.generic.edit.FormMixin.form_class): атрибут, який вказує на клас форми; замість нього можна визначати метод [get_form_class](http://djbook.ru/rel1.7/ref/class-based-views/mixins-editing.html#django.views.generic.edit.FormMixin.get_form_class);
* initial: атрибут, словник із початковими даними для форми;
* success_url: атрибут, адреса сторінки для редіректу після успішної обробки форми; замість нього можна використовувати метод [get_success_url](http://djbook.ru/rel1.7/ref/class-based-views/mixins-editing.html#django.views.generic.edit.FormMixin.get_success_url);
* form_valid: метод, який редіректить на сторінку при успішній обробці форми;
* form_invalid: рендерить відповідь користувачу, що містить форму із вказаними помилками.

Клас для форми створення нового об'єкта [CreateView](http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#createview):

* object: атрибут, який вказує на новостворений об'єкт;
* решта методів і атрибутів, що були згадані в переліку до класу FormView.

Клас для форми редагування існуючого об'єкта [UpdateView](http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#updateview). Підтримує усі атрибути і методи визначені у класі CreateView.

Клас для видалення існуючого об'єкта із бази [DeleteView](http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#deleteview). Найважливіші атрибути - це model та success_url.

Як користуватись базовою формою і в'юшкою-функцією ми уже знаємо із секції про розробку форми контакту адміністратора. А ось так можна це зробити використовуючи клас. Наводжу спрощений варіант логіки:

{title="Контакт форма через клас в'юшки",lang="python"}
~~~~~~~~
from django.views.generic.edit import FormView

class ContactView(FormView):
    template_name = 'contact_form.html'
    form_class = ContactForm
    success_url = '/email-sent/'

    def form_valid(self, form):
        """This method is called for valid data"""
        subject = form.cleaned_data['subject']
        message = form.cleaned_data['message']
        from_email = form.cleaned_data['from_email']

        send_mail(subject, message, from_email, ['admin@gmail.com'])

        return super(ContactView, self).form_valid(form)
~~~~~~~~

A> На домашнє завдання: повністю перепишіть функцію-в'юшку форми контакту адміністратора на клас, який буде унаслідуватись від FormView.

FormView клас для нас визначає набір методів і атрибутів таким чином, що нам не треба писати багато умовних операторів для перевірки на тип запиту і тому подібні речі.

**Форми роботи з моделями**

Класи UpdateView, CreateView i DeleteView є, так званими, в'юшками для роботи із моделями. Кожна із них змінює певним чином базу даних і оперує над тим чи іншим класом моделі.

Щоб вказати даним класам, з якими об'єктами вони працюватимуть використовуються наступні варіанти в порядку їхньої важливості:

* якщо визначений атрибут "model" на рівні класу, тоді він використовується;
* якщо визначений метод "get_object" повертає об'єкт, тоді клас даного об'єкту використовуватиметься як модель;
* якщо визначений "queryset", тоді модель визначена у ньому буде використовуватись у подальшій роботі класу-в'юшки.

C> ...

На цьому з теорією завершуємо і переходимо до практики. Реалізуємо форму редагування студента.

Але вам, перед переходом до практики, рекомендую ще добряче начитатись [про форми](http://djbook.ru/rel1.7/topics/class-based-views/index.html) і спробувати самостійно розібратись, якщо інформації даної секції не вистачило вам для повного розуміння.

### В'юшка-Клас для редагування студента

Цього разу почнемо не із під'єднання шаблонів, а прямо із класу в'юшки. Відкриваємо у своєму улюбленому редакторі коду модуль students.py із пакету views в аплікації students і додаємо наступний клас:

{title="Клас-в'юшка для редагування студента",lang="python"}
~~~~~~~~
from django.http import HttpResponse, HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.views.generic import UpdateView

from ..models import Student, Group

class StudentUpdateView(UpdateView):
    model = Student
    template_name = 'students/students_edit.html'

    def get_success_url(self):
        return u'%s?status_message=Студента успішно збережено!' \
            % reverse('home')

    def post(self, request, *args, **kwargs):
        if request.POST.get('cancel_button'):
            return HttpResponseRedirect(
                u'%s?status_message=Редагування студента відмінено!' %
                reverse('home'))
        else:
            return super(StudentUpdateView, self).post(request, *args, **kwargs)
~~~~~~~~

Думаю, більшість речей зрозуміла базуючись на матеріалі попередньої секції, але, все ж таки, коротенько пройдемось по важливих моментах:

* 3ій рядок: усі дефолтні в'юшки-класи Django живуть в пакеті "django.views.generic";
* 7ий: наш клас в'юшки унаслідується від класу UpdateView, адже ми реалізуємо форму редагування;
* 8ий: модель, з якою працюватиме наша сторінка - Student;
* 9ий: шаблон для сторінки редагування сторінка лежить за адресою "students/students_edit.html";
* 11ий: метод, який повертає URL сторінку для редіректу після успішного збереження студента;
* 15ий: метод post ми також кастомізнули, щоб окремо обробляти кнопку "Скасувати" на формі; при її натиску ми переадресовуємо користувача на сторінку із списком студентів;
* 22ий: а всю важку роботу (валідація даних, збереження студента, підготовка помилок при некоректних даних) для нас зробить метод "post" батьківського класу.

Ось і все! Важко повірити, що 23 рядочки коду (разом із імпортами) - це все, що потрібно для редагування студента? Мені також було важко у це повірити, коли я вперше познайомився із даними формами.

А тепер скопіюємо шаблон для редагування студента із шаблону додавання студента:

{title="Копіюємо шаблон додавання студента",lang="shell"}
~~~~~~~~
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/templates/students
$ cp students_add.html students_edit.html
~~~~~~~~

Відкриваємо students_edit.html і приводимо до наступного вигляду:

{title="Шаблон для роботи із в'юшкою-класом, students_edit.html",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}

{% block meta_title %}Редагувати Студента{% endblock meta_title %}

{% block title %}Редагувати Студента{% endblock title %}

{% block status_message %}
{% if form.errors %}
<div class="alert alert-warning" role="alert">Будь-ласка, виправте наступні помилки</div>
{% endif %}
{% endblock %}

{% block content %}

<form action="{% url "students_edit" object.id %}" method="post" enctype="multipart/form-data">
  {% csrf_token %}

  {{ form.as_p }}

  <input type="submit" value="Зберегти" name="add_button"
         class="btn btn-primary" />
  <button type="submit" name="cancel_button" value="Скасувати"
          class="btn btn-link">Скасувати</button>
</form>


{% endblock content %}
~~~~~~~~

В даному шаблоні ми:

* оновили заголовки сторінки;
* кастомізували блок status_message, щоб виводити помилки валідації форми;
* вставили змінну форми "{{ form.as_p }}" аналогічно як зробили це з формою контакту адміністратора.

Нічого нового в даному шаблоні для нас не з'явилось. Зауважте, що даний клас в'юшки навіть не потребував класу форми, а згенерував для нас усі поля форми просто маючи атрибути "model" встановлений в значення Student. Атрибут класу form_class нам пригодиться, коли застосуємо Crispy Forms стилі до нашої форми.

Залишилась єдина зміна: оновити urls.py шаблон для сторінки із формою редагування:

{title="urls.py",lang="python"}
~~~~~~~~
...
from students.views.students import StudentUpdateView
...
urlpatterns = patterns('',
    ...
    url(r'^students/(?P<pk>\d+)/edit/$',
         StudentUpdateView.as_view(),
         name='students_edit'),
    ...
~~~~~~~~

URL шаблони вміють працювати лише із об'єктами, що можна викликати (callable), тому передати напряму клас ми не можемо. Натомість, маємо в класах в'юшок статичний метод "as_view", який спеціально призначений для повернення функції, що огортає наш клас у вигляд функції для URL шаблона.

Все. Отак, кількома рядками коду, навіть без декларації класу форми, а лише із класом в'юшки, ми маємо повноцінну форму редагування студента разом із валідацією та збереженням даних в базу.

A> На домашку: спробуйте зробити форму редагування визначивши окремо клас форми і вручну прописавши усі необхідні поля. Так само як ми це робили із формою контакту. Просто для практики і, щоб запам'ятати.


### Crispy Forms стилі

На завершення даної секції приведемо нашу форму редагування студента до прийнятного вигляду. Знову ж таки використовуючи Crispy Forms аплікацію.

Усі дії аналогічні до тих, які ми проробляли з формою контакту адміна. Тому зробимо це доволі швидко і без додаткових дублюючих пояснень.

Якщо до цього моменту ми обходились без класу форми, то тепер маємо його створити, щоб встановити об'єкт класу FormHelper атрибутом у форму.

Ось як виглядатиме клас форми редагування студента:

{title="Клас форми студента, views/students.py",lang="python"}
~~~~~~~~
# -*- coding: utf-8 -*-
from datetime import datetime

from django.shortcuts import render
from django.http import HttpResponse, HttpResponseRedirect
from django.core.urlresolvers import reverse
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.forms import ModelForm
from django.views.generic import UpdateView

from crispy_forms.helper import FormHelper
from crispy_forms.layout import Submit
from crispy_forms.bootstrap import FormActions

from ..models import Student, Group


class StudentUpdateForm(ModelForm):
    class Meta:
        model = Student

    def __init__(self, *args, **kwargs):
        super(StudentUpdateForm, self).__init__(*args, **kwargs)

        self.helper = FormHelper(self)

        # set form tag attributes
        self.helper.form_action = reverse('students_edit',
            kwargs={'pk': kwargs['instance'].id})
        self.helper.form_method = 'POST'
        self.helper.form_class = 'form-horizontal'

        # set form field properties
        self.helper.help_text_inline = True
        self.helper.html5_required = True
        self.helper.label_class = 'col-sm-2 control-label'
        self.helper.field_class = 'col-sm-10'

        # add buttons
        self.helper.layout[-1] = FormActions(
            Submit('add_button', u'Зберегти', css_class="btn btn-primary"),
            Submit('cancel_button', u'Скасувати', css_class="btn btn-link"),
        )

class StudentUpdateView(UpdateView):
    model = Student
    template_name = 'students/students_edit.html'
    form_class = StudentUpdateForm

    def get_success_url(self):
        return u'%s?status_message=Студента успішно збережено!' \
            % reverse('home')

    def post(self, request, *args, **kwargs):
        if request.POST.get('cancel_button'):
            return HttpResponseRedirect(
                u'%s?status_message=Редагування студента відмінено!' %
                reverse('home'))
        else:
            return super(StudentUpdateView, self).post(request, *args, **kwargs)
~~~~~~~~

Ми створили клас форми StudentUpdateForm, який унаслідується від ModelForm. Завдяки унаслідуванню наша форма отримує увесь функціонал по роботі із моделями і базою даних.

Подібним чином як ми це робили із формою контакту адміністратора, ми визначили об'єкт helper та "набили" його рядом атрибутів для кращого візуального представлення форми. Єдина відмінність полягає у тому, що тут ми додали дві кнопки та огорнули їх у лейаут FormActions (рядок 41). Він додасть спеціальний огортаючий тег div для тегів кнопок. Пізніше можна його використати для кастомних стилів.

Також в класі в'юшки, у рядку 51, ми під'єднали клас форми з допомогою атрибуту form_class. Все решта у даному класі залишилось без змін.

Тепер черга за шаблоном. Що і як в ньому робити після застосування Crispy Forms ви уже знаєте:

{title="Шаблон форми редагування студента із Crispy Forms",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}
{% load crispy_forms_tags %}

{% block meta_title %}Редагувати Студента{% endblock meta_title %}

{% block title %}Редагувати Студента{% endblock title %}

{% block status_message %}
{% if form.errors %}
<div class="alert alert-warning" role="alert">Будь-ласка, виправте наступні помилки</div>
{% endif %}
{% endblock %}

{% block content %}

{% crispy form %}

{% endblock content %}
~~~~~~~~

Ми завантажили теги із Crispy Forms аплікації та замінили тег форми тегом "{% crispy form %}. Це все.

Знову оновіть сторінку із формою редагування студента і переконайтесь, що ваш результат є подібним на наступне зображення:

![Форма редагування студента готова!](images/edit_student_form_ready.jpg)


A> На домашнє завдання: перевести форму додавання студента також на форму моделей Django i користуватись єдиним шаблоном як для додавання, так і для редагування студента.

A> Ще одна вправа: спробувати переписати форму редагування студента без використання Django форм - повністю вручну. Так само, як ми це робили із формою додавання студента. З метою практики. Дасть вам гарне розуміння роботи із даними з бази та даними від користувача. Тут буде кілька нюансів, яких не було із формою додавання. Плюс логіка по збереженні об'єкта в базу, звичайно, буде трохи іншою.

Як бачите, використання Django форм для роботи із моделями дозволило нам кількома рядками Python коду реалізувати доволі складну форму. В наступних главах книги ми ще матимемо справу із Django формами.

## Видалення студента

Додавати та редагувати існуючого студента ми уже навчились, і думаю, зможемо робити подібні речі доволі просто і швидко. На порядку денному - розібратись із видаленнями існуючих об'єктів з бази даних.

Для цього знову скористаємось максимально швидким способом: Django класами в'юшок для роботи із моделями - [DeleteView](http://djbook.ru/rel1.7/ref/class-based-views/generic-editing.html#deleteview).

Наш власний клас буде унаслідуватись від DeleteView та декларуватиме два атрибута та один метод:

* model: клас моделі, над яким оперуватиме;
* template_name: шлях до шаблону, що міститиме підтверджуюче повідомлення про видалення студента;
* get_success_url: метод, що повертатиме шлях редіректу після успішного видалення студента.

Ось необхідні оновлення до нашого модуля із в'юшками students.py:

{title="Клас-в'юшка для видалення студента",lang="python"}
~~~~~~~~
class StudentDeleteView(DeleteView):
    model = Student
    template_name = 'students/students_confirm_delete.html'

    def get_success_url(self):
        return u'%s?status_message=Студента успішно видалено!' \
            % reverse('home')
~~~~~~~~

Як бачите, нам знову не довелось писати жодної логіки по валідації форми чи видаленні об'єкта із бази даних.

Тепер скопіюємо один із існуючих кінцевих шаблонів у "students_confirm_delete.html". Цей шаблон відображатиме повідомлення про підтвердження видалення студента. Важливо не одразу видаляти студента при кліку на Дію Видалити, а ще раз перепитати користувача про остаточне видалення. Адже ця дія остаточна:

{title="Створюємо шаблон students_confirm_delete.html",lang="shell"}
~~~~~~~~
$ cd /data/work/virtualenvs/studentsdb/src/studentsdb/students/templates/students
$ cp students_edit.html students_confirm_delete.html
~~~~~~~~

Відкриваємо новий шаблон і оновлюємо наступним кодом:

{title="Кінцевий вигляд шаблону students_confirm_delete.html",lang="html"}
~~~~~~~~
{% extends "students/base.html" %}

{% load static from staticfiles %}

{% block meta_title %}Видалити Студента{% endblock meta_title %}

{% block title %}Видалити Студента{% endblock title %}

{% block content %}

<form action="{% url "students_delete" object.id %}" method="post">
  {% csrf_token %}
  <p>Ви дійсно хочете видалити студента "{{ object }}"?</p>
  <input type="submit" value="Так" name="delete_button"
         class="btn btn-danger" /><br /><br />
</form>

{% endblock content %}
~~~~~~~~

Як бачите код доволі простий. Ми додали форму, яка відсилає дані на себе ('{% url "students_delete" object.id %}') і містить запитання, чи дійсно користувач хоче видалити студента. Також додали кнопку "Так" для підтвердження дії.

Зверніть увагу, що в'юшка DeleteView також передає поточний об'єкт студента під змінною "object" в шаблоні. Ще одна цікава річ: коли вставляємо напряму об'єкт в шаблон ("{{ object }}"), тоді використовується його метод "\_\_unicode\_\_" для генерації стрічки-представлення об'єкта на нашій сторінці.

Залишилась остання річ: оновити URL шаблон для нашої сторінки підтвердження видалення студента:

{title="DeleteView в urls.py",lang="python"}
~~~~~~~~
from students.views.students import StudentUpdateView, StudentDeleteView

...
    url(r'^students/(?P<pk>\d+)/delete/$',
         StudentDeleteView.as_view(),
         name='students_delete'),
...
~~~~~~~~

Що ми змінили в даному модулі:

* додали імпорт StudentDeleteView;
* змінили назву групи із "sid" студента на "pk";
* змінили посилання на в'юшку: "StudentDeleteView.as_view()".

Готово! У списку дій студента обирайте "Видалити" і видаліть одного із студентів. Переконтайтесь, що вигляд та функціонал форми працює коректно.

![Видалення студента](images/student_delete.jpg)

A> На домашнє завдання: реалізувати аналогічним чином видалення груп.

A> Ще одне завдання: реалізувати видалення студента повністю вручну без Django форм.

A> Ну і для зовсім "просунутих". Реалізувати можливість видалення одразу кількох студентів. Для цього треба буде додати чекбокси до списку із студентами, а також кнопки Видалити внизу або зверху даного списку.

Черговий раз переконуємось на скільки швидко та легко створювати стандартний функціонал по роботі із базою даних, якщо під руками Django форми. Звичайно, спочатку треба провести деякий час практикуючись із ними, але пізніше це окуповується з вторицею.

## Кастомізація адміністративної частини Django

На завершення даної глави оглянемо, яким чином можна змінювати адмін інтерфейс Django. Спочатку розберемо теоретичні основи і можливості для кастомізації, а потім зробимо 2 практичні задачі:

* покращимо список студентів в адмінці функціями пошуку, фільтру та редагуванням;
* реалізуємо валідацію моделі студента, щоб не можна було призначити студента до групи, якщо він є старостою в іншій групі; тобто група має співпадати із тою, де даний студент є старостою.


### Теорія адмінки

Django надає [широкі можливості](http://djbook.ru/rel1.7/ref/contrib/admin/index.html) для кастомізації адміністративної частини.

Усі зміни відбуваються через власний Python клас, який повинен унаслідуватись від ModelAdmin.

Ось список найчастіше використовуваних атрибутів і методів даного класу для кастомізації адмін частини тієї чи іншої моделі:

* actions: список додаткових дій над елементами в списку моделей; зазвичай ці дії розробнику потрібно самому реалізувати;
* actions_selection_counter: показувати чи ні лічильник вибраних серед списку об'єктів;
* exclude: список полів, які виключити із форми редагування моделі;
* fields: список полів, які включити у форму редагування моделі;
* form: призначення кастомного класу форми; використовується для серйозніших змін у функціонал та вигляд форми редагування моделі; пізніше ми скористаємось даним атрибутом;
* list_display: список полів моделі для відображення у списку;
* list_display_links: які із полів моделі у списку будуть огорнуті в лінк, який вказуватиме на форму редагування об'єкта
* list_editable: список полів, які можна буде поредагувати прямо у списку об'єктів; не заходячи на форму редагування;
* list_filter: список полів для генерації фільтрів;
* list_per_page: кількість об'єктів на одній сторінці;
* ordering: список полів, по яких початково сортувати об'єкти;
* readonly_fields: список полів, які не можна буде редагувати на формі;
* search_fields: список полів, по яких можна буде робити пошук об'єктів;
* view_on_site: метод, що повертає URL адресу до фронт-енд в'юшки об'єкта.

Ще є багато інших атрибутів і методів, які, буквально, дозволяють повністю переписати форми і шаблони адмінки ваших моделей. Але їх розглядати тут не будемо.

Таким чином, достатньо визначити свій клас і прописати необхідні методи та атрибути всередині, щоб впливати на вигляд та функціонал адміністративної частини обраної моделі. А почнемо із покращення функцій для списку студентів.

### Покращуємо список студентів в адмінці

Ось як виглядає список студентів на даний момент. Порівняємо його наприкінці даної секції, коли матимемо усі покращення:

![Дефолтна адмінка списку студентів](images/students_list_admin.jpg)

Ми уже раніше зареєстрували клас моделі студента для Django адмінки, і тепер залишається лише визначити окремий клас для адмін в'юшки і підв'язати її до моделі студента. Поки вона буде у нас порожня:

{title="Адмін в'юшка, модуль admin.py в корені аплікації students",lang="python"}
~~~~~~~~
# -*- coding: utf-8 -*-
from django.contrib import admin

from .models import Student, Group

class StudentAdmin(admin.ModelAdmin):
    pass

admin.site.register(Student, StudentAdmin)
admin.site.register(Group)
~~~~~~~~

Ми створили клас StudentAdmin i унаслідували його від ModelAdmin, адже усі в'юшки в адмінці - це в'юшки для роботи із моделями. Крім того, ми передали даний клас другим аргументом у функцію "register". Тепер модель студента зв'язана із новоствореним класом в'юшки.

Ми готові до того, щоб "нафарширувати" наш клас корисними речима:

{title="Покращуємо вигляд списку студентів",lang="python"}
~~~~~~~~
from django.core.urlresolvers import reverse

class StudentAdmin(admin.ModelAdmin):
    list_display = ['last_name', 'first_name', 'ticket', 'student_group']
    list_display_links = ['last_name', 'first_name']
    list_editable = ['student_group']
    ordering = ['last_name']
    list_filter = ['student_group']
    list_per_page = 10
    search_fields = ['last_name', 'first_name', 'middle_name', 'ticket',
        'notes']

    def view_on_site(self, obj):
        return reverse('students_edit', kwargs={'pk': obj.id})
~~~~~~~~

Тепер давайте порядково ще раз пройдемось по доданих атрибутах і методах класу:

* 4ий рядок: відображаємо в заданому порядку Прізвище, Ім'я, Білет та Групу студента у списку;
* 6ий: поля Ім'я та Прізвище будуть залінковані на форму редагування студента;
* 7ий: поле Група можна тепер буде редагувати пряму на списку студентів; це пришвидшить дії адміністратора по розподілу студентів по групах;
* 8ий: по-замовчуванню список студентів буде посортований по прізвищу;
* 9ий: в правій колонці біля списку студентів з'явиться можливість фільтрувати студентів по групах; це зручно для роботи із студентами в контексті тої чи іншої групи;
* 10ий: вказуємо посторінковій навігації відображати 10 студентів на одній сторінці;
* 11ий: додаємо форму пошуку студентів, яка шукатиме серед усіх текстових полів у моделі студента: Прізвище, Ім'я, По-батькові, Білет та Додаткові нотатки;
* 15ий: додаємо кнопку "Переглянути на сайті" до форми редагування студента; таким чином адміністратор зможе одним кліком відвідати фронт-енд представлення поточного студента; у нашому випадку це форма редагування студента; даний метод "view_on_site" повертає URL адресу сторінки.

Все доволі просто і згідно тих визначень, які ми переглянули в попередній секції із теоретичним вступом.

Після усіх вищеперечислених змін ось як виглядатиме наш список студентів:

![Список студентів покращений](images/students_list_admin_improved.jpg)

Форма пошуку, фільтри, сортування, поля, редагування, посторінкова навігація - усе це та ще дещо, ми змогли зробити кількома стрічками коду у класі в'юшки управління виглядом студентів в адміністративній частині Django.

A> На домашнє завдання: кастомізуйте список груп в адміністративній частині Django подібним чином до того, як ми це зробили із списком студентів. Додайте функції пошуку та фільтру, щоб працювати із групами було значно зручніше.

Складніше завдання: розібратись із [діями](http://djbook.ru/rel1.7/ref/contrib/admin/actions.html) в Django адмінці і реалізувати функцію копіювання обраних студентів у списку.

Тепер перейдемо до дещо складнішого завдання.

### Валідатор для поля Групи

Кожен із студентів повинен бути призначений в ту чи іншу групу. В той же час, деякі із студентів можуть бути обрані в якості старост для груп.

На даний момент на формі редагування студента в адміністративній частині ми можемо обирати будь-яку існуючу групу в полі Група. Насправді в реальному житті не буває так, щоб студент навчався в одній групі, а був старостою іншої групи. Проте, використовуючи наші адмін форми, ми можемо таке зробити. Потрібно виправити даний функціонал і убезпечити адміністратора сайту від подібних помилок з налаштування студентів та груп.

Бути в курсі усіх студентів, груп та старост є непосильною задачею для людини, тому розв'язок даної проблеми повинен лежати на рівні коду, а не на рівні інструктажу персоналу нашої аплікації.

Це все можна виправити з допомогою додаткової валідації поля Група на формі редагування студента. При кожній спробі оновити студента ми будемо перевіряти чи обрана група співпадає із групою, в якій даний студента являється старостою. Звичайно, якщо даний студент не є старостою в жодній групі, тоді і перевіряти нічого не потрібно. Будь-яка група для нього є дозволеною.

Із специфікаціями даного завдання розібрались, тому переходимо безпосередньо до реалізації коду.

Щоб додати валідатор потрібно мати клас форми. На даний момент ми його ще не створили. Тому додаємо форму і пропишемо її в атрибут form_class нашої в'юшки, щоб зв'язати їх один із одним. Наводжу одразу кінцевий код валідаційного методу, а після цього розберемось в деталях:

{title="Валідація поля student_group",lang="python"}
~~~~~~~~
# -*- coding: utf-8 -*-
from django.contrib import admin
from django.core.urlresolvers import reverse
from django.forms import ModelForm, ValidationError

from .models import Student, Group


class StudentFormAdmin(ModelForm):

    def clean_student_group(self):
        """Check if student is leader in any group.

        If yes, then ensure it's the same as selected group."""
        # get group where current student is a leader
        groups = Group.objects.filter(leader=self.instance)
        if len(groups) > 0 and \
            self.cleaned_data['student_group'] != groups[0]:
            raise ValidationError(u'Студент є старостою іншої групи.',
                code='invalid')

        return self.cleaned_data['student_group']

class StudentAdmin(admin.ModelAdmin):
    list_display = ['last_name', 'first_name', 'ticket', 'student_group']
    list_display_links = ['last_name', 'first_name']
    list_editable = ['student_group']
    ordering = ['last_name']
    list_filter = ['student_group']
    list_per_page = 10
    search_fields = ['last_name', 'first_name', 'middle_name', 'ticket',
        'notes']
    form = StudentFormAdmin

    def view_on_site(self, obj):
        return reverse('students_edit', kwargs={'pk': obj.id})

admin.site.register(Student, StudentAdmin)
admin.site.register(Group)
~~~~~~~~

Давайте порядково пройдемось по останніх оновленнях:

* 9ий рядок: декларуємо клас StudentFormAdmin, який унаслідує від ModelForm;
* 11ий: у Django формах перед викликом методів is_valid та is_invalid викликаються методи валідації та перетворення даних із назвами clean_[назва поля]; ми скористались даним підходом та перекрили метод валідація саме поля групи "clean_student_group"; він не приймає жодних атрибутів, але поточний об'єкт форми має атрибут cleaned_data, яким ми і скористаємось, щоб дізнатись яку саме групу обрав користувач на формі редагування студента;
* 16ий: витягуємо усі групи з бази даних, в яких даний студента є призначений старостою;
* 17ий: якщо даний студент є старостою хоча б в одній групі, а також ця група не співпадає із групою, яка була щойно обрана на формі редагування...;
* 19ий: тоді викидаємо спеціальну помилку ValidationError, якій передаємо повідомлення для відображення користувачеві;
* 23ій: у випадку, якщо валідація проходить успішно, ми просто повертаємо значення обраного поля student_group із методу;
* 36ий: прив'язуємо наш клас форми до адмін в'юшки.

Тепер, щоб потестувати наш валідатор, потрібно відповідно налаштувати групу та студента. В одній із груп додайте студента в якості старости. Потім на формі редагування даного студента спробуйте обрати іншу групу і зберегти. При цьому ви повинні отримати повідомлення над полем: "Студент є старостою іншої групи.".

A> Як розумієте валідація лише із сторони форми студента буде неповною, адже ще залишається можливість на формі групи вибирати старосту. Тому даю вам на самостійне опрацювання реалізацію валідатора поля Староста Групи. Даний валідатор не дозволить обрати студента, якщо він не належить до поточної групи (тобто його поле student_group не вказує на дану групу).

A> Ще одне завдання. Додайте аналогічну валідацію до наших власних фронте-енд форм редагування студента та групи.

A> Не забуваємо про репозиторій коду і регулярні коміти окремими завданнями та із гарними пояснювальними коментарями.


## Домашнє завдання

Протягом даної глави ми освоїли масу нового матеріалу. Давайте підсумуємо:

* робота із HTML формами;
* обробка форм, валідація, робота із помилками;
* використання Django форм та форм роботи із моделями;
* реалізація форм додавання, видалення та редагування об'єктів в базі;
* створення правильним статусних повідомлень та відповідей після дій над формами;
* використання Twitter Bootstrap стилів з допомогою Crispy Forms аплікації;
* кастомізація Django адміністративного інтерфейсу.

В кожній із секцій ви зустрічали далеко не одне домашнє завдання. Як ви розумієте, вони там не лише для прочитання, але й для самостійної реалізації. Тому виділіть собі кілька днів, а може і тижнів, щоб хоча б спробувати кожне із них.

А для тих, кому все дається занадто легко, ось ще декілька ідей і нагадувань:

* реалізуати усі (редагування, додавання та видалення) форми роботи із Студентами, Групами та Іспитами;
* реалізувати дані форми двома способами: повністю вручну та з допомогою Django форм роботи з моделями.

*Я спеціально даю вам таку рутинну роботу. Адже з кількістю прийде якість і повне розуміння концепцій. Зазвичай, якщо я щось не розумію, я його завчаю, і після цього розуміння неодмінно приходить.*

Тому не лінуйтесь і результати вже будуть не за горами.

Також в коді, що йде із книгою можете знайти код форм менеджменту групами. Там почерпнете декілька нових фішок, які ми не оглянули в даній главі.

C> ...

Таким чином, даною главою ми закінчуємо найбазовіший матеріал книги. Форми, моделі та в'юшки - це необхідний мінімум базових знань, без яких неможливо знайти роботи та й взагалі рухатись далі. Так, він не є достатнім, але без нього нікуди. Тому виділіть достатньо часу на ці три глави.

В наступній главі ми перейдемо до динамічних сторінок, реалізуємо закладку Відвідування, ознайомимось із мовою Javascript та технологією AJAX, зробимо випадаюче меню груп робочим.